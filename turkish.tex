\documentclass[a4paper,12pt,oneside]{book}

\usepackage[english,turkish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{listingsutf8}
\usepackage{gensymb}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\leftmark}
\fancyhead[RE,LO]{\thepage}

\definecolor{gray75}{gray}{0.75}

\newcommand{\hsp}{\hspace{20pt}}

\titleformat{\chapter}[hang]{\filleft\Huge\bfseries}{Bölüm \thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

\begin{document}

\author{Dennis M. Ritchie \\
\newline Brian W. Kernighan \\
\newline \small İngilizce Aslından Çeviren: Serhan Ekmekçi}

\title{C Programlama Dili İkinci Tiraj}
\date{}

\lstset{
    escapeinside={(*}{*)},
    frame=tb,
    breaklines=true,
    breakatwhitespace=true,
    basicstyle={\footnotesize\ttfamily},
    numbers=none,
    columns=flexible,
    tabsize=4,
    inputencoding=utf8,
    extendedchars=true,
    % Turkish chars
    literate=%
    {Ö}{{\"O}}1
    {Ü}{{\"U}}1
    {ü}{{\"u}}1
    {ö}{{\"o}}1
    {ı}{{\i}}1
    {İ}{{\.{I}}}1
    {ğ}{{\u{g}}}1
    {Ğ}{{\u{G}}}1
    {ş}{{\c{s}}}1
    {Ş}{{\c{S}}}1
    {ç}{{\c{c}}}1
    {Ç}{{\c{C}}}1
}
\frontmatter

\fancypagestyle{preface}{\fancyhf{}\renewcommand{\headrulewidth}{0.5pt}\fancyhead[LE,RO]{Önsöz}\fancyhead[RE,LO]{\thepage}}

\fancypagestyle{prefacetofe}{\fancyhf{}\renewcommand{\headrulewidth}{0.5pt}\fancyhead[LE,RO]{İlk Tiraja Önsöz}\fancyhead[RE,LO]{\thepage}}

\fancypagestyle{introduction}{\fancyhf{}\renewcommand{\headrulewidth}{0.5pt}\fancyhead[LE,RO]{Giriş}\fancyhead[RE,LO]{\thepage}}


\maketitle

\tableofcontents

\chapter{Önsöz}

Bilgi işlem dünyası, 1978 yılında "C Programlama Dili"nin yayınlanmasından itibaren köklü bir devrime uğramıştır. Büyük bilgisayarlar artık daha da büyükler ve kişisel bilgisayarlar artık on yıl öncesinin ana bilgisayarlarına rakip olabilecek kapasitedeler. Bu zaman içerisinde, mütevazi bir şekilde olsa da C de değişime uğradı ve kendi orijini olan sadece UNIX işletim sisteminin dili olmaktan çok uzaklara yayıldı.
\par C'nin gittikçe artan popülaritesi, yıllar içerisinde dilde gerçekleşen değişimler ve gruplar tarafından derleyicilerin (\textbf{compilers}) oluşturulması onun dizaynına bulaştırılmadı; dilin daha açık ve kitabın ilk tirajına göre daha çağdaş bir tarifi için kombine edildi. 1983'te Amerikan Ulusal Standartları Enstitüsü (\textbf{American National Standards Institue}) (ANSI) amacı, C dilinin, ruhunu kaybettirmeden kesin ve makineye dayalı olmayan bir tarifini üretmek olan bir komite kurmuştur. Sonuç, C için "ANSI" standardıdır.
\par Standart, ilk tirajda bahsi geçmiş fakat tam anlamıyla tarif edilmemiş (\textbf{define}) yapıları formüllendiriyor. Özellikle yapı ataması ve numaralandırma gibi konularda. Bu; fonksiyon (\textbf{function}) deklarasyonunun çapraz-kontrole (\textbf{cross-checking}) izin veren, kullanımla beraber bir tarifini (\textbf{definition}) sağlar. Girdi (\textbf{input}) ve çıktıları (\textbf{output}) sergilemek için olan fonksiyonların (\textbf{functions}) geniş bir dizisi, hafıza yönetimi, dize manipülasyonu ve benzer görevlerle birlikte standart bir kütüphane belirtir. Orijinal tarifte ayrıntılı olarak açıklanmamış özelliklerin davranışlarını açık ve kesin bir hale getirir ve aynı zamanda dilin makineye dayalı kalan yönlerini açık bir şekilde belirtir.
\par C Programlama Dili'nin ikinci tirajı, C'yi ANSI standartlarında olduğu gibi açıklar. Biz, dilin evrildiği yerleri belirtmiş olmamıza rağmen bilerek yeni formda yazmayı tercih ettik. Büyük bir bölüm için bu, çok önemli bir fark yaratmaz. En gözle görülür değişim, fonksiyon (\textbf{function}) deklarasyonunun ve tarifinin (\textbf{definition}) yeni formudur. Modern derleyiciler (\textbf{compilers}) standardın özelliklerinin çoğunu çoktan desteklemektedir.
\par Kitabı ilk tirajın kısalığında tutmaya çalıştık. C, büyük bir dil değil ve büyük bir kitap onun çok işine yaramaz. C programlamanın merkezi olan işaretleyiciler (\textbf{pointers}) gibi kritik özelliklerin anlatımını geliştirdik. \pagebreak


\thispagestyle{preface} \noindent Orijinal örnekler işledik ve birkaç bölüme yeni örnekler ekledik. Örneğin; komplike deklarasyonların işlemleri deklarasyonları kelimelere dönüştüren programlar ile karşılıklı olarak arttırıldı. Önceden olduğu gibi bütün örnekler doğrudan, makine tarafından okunulabilir formda olan metinden test edilmiştir.
\par Ek Bölüm A; referans el kitabı, standart değildir. Fakat bizim girişimimiz standardın gerekliliklerini daha küçük bir alanda iletmek. Bu programcılar tarafından kolay anlaşılmak üzere yapıldı ancak derleyici (\textbf{compiler}) yazarları için bir açıklama olarak yapılmadı. - Bu görev tamamen standardın kendisine düşüyor. Ek Bölüm B, standart kütüphanenin özetidir. Ve bu da dahil ediciler (\textbf{implementers}) için değil programcılar için referans edildi. Ek Bölüm C, orijinal versiyondaki değişimlerin kısa özetidir.
\par İlk tirajın önsözünde de söylediğimiz gibi C "sizlerden gelişen tecrübeyle hala iyi kalmayı başarıyor." On yılların getirdiği tecrübe ile birlikte biz hala bu şekilde hissediyoruz. Umuyoruz ki bu kitap, C'yi öğrenmenizde ve iyi bir şekilde kullanmanızda yardımcı olur.
\par Bu ikinci tirajı ortaya çıkarmamızda yardımcı olan arkadaşlarımıza derinden borçlu hissediyoruz.  Jon Bentley, Doug Gwyn, Doug Mcllroy, Peter Nelson ve Rob Pike bize neredeyse taslağın her sayfasında sezgilerinden yola çıkarak yorumlarda bulundular. Dikkatli okumaları için  Al Aho, Dennis Allison, Joe Campbell, G. R. Emlin, Karen Fortgang, Allen Holub, Andrew Hume, Dave Kristol, John Linderman, Dave Prosser, Gene Spafford, ve Chris Van Wyk'e minnettarız. Ayrıca  BHl Cheswick, Mark Kernighan, Andy Koenig, Robin Lake, Tom London, Jim Reeds, Clovis Tondo, ve Peter Weinberger'den yardımcı tavsiyeler aldık. Dave Prosser ANSI standartları hakkında birçok detaylı sorumuzu cevapladı. Programlarımızın yerel testleri için yaygın olarak  Bjarne Stroustrup'ın C++ çeviricisini kullandık ve Dave Kristol bize final testi için bir ANSI C derleyicisi (\textbf{compiler}) sağladı. Rich Drechsler dizgilerde bize son derece yardımcı oldu.
\par Hepsine içten teşekkürlerimizle.
\newline

\noindent \hspace*{270pt}{Brian W. Kernighan \\}
\hspace*{280pt}{Dennis M. Ritchie}

\chapter*{İlk Tiraja Önsöz}
\addcontentsline{toc}{chapter}{İlk Tiraja Önsöz}

C; açıklama (\textbf{expression}) idaresi, modern kontrol akışı (\textbf{control-flow}), veri yapıları (\textbf{structers}) ve zengin bir operatör grubu içeren özellikte, genel amaçlı bir programlama dilidir. C ne bir "çok yüksek seviyeli" ne de büyük bir dil değildir ve herhangi bir uygulamanın belirli bir bölümü için özelleştirilmemiştir. Fakat kısıtlamalarının olmaması ve yaygınlığı onu birçok görev için sözde daha güçlü dillerden daha elverişli ve etkili yapıyor.
\par C orijinal olarak "UNIX" işletim sisteminde, DEC PDP-11 üzerinde Dennis Ritchie tarafından tasarlanmış ve uygulanmıştır. İşletim sistemi, C derleyicisi (\textbf{compiler}) ve aslında tüm "UNIX" uygulama programları (bu kitabı hazırlamak için kullanılan tüm yazılımlar dahil) C dilinde yazılıyor. Üretim derleyicileri (\textbf{compilers}) ayrıca IMB Sistem/370, Honeywell 6000 ve Interdata 8/32'yi içeren diğer birkaç makine için de bulunmakta. C, belirli hiçbir donanım ve sisteme bağlı değil ve C destekleyen bir makineden diğerine herhangi bir değişim yapmadan çalışacak programlar yazmak oldukça kolay.
\par Bu kitap okurun C'de programlamanın nasıl olduğunu öğrenmesine yardım etmek içindir. Yeni kullanıcıların mümkün olan en kısa sürede başlaması için öğretici bir giriş, her majör özellik için ayrı bölüm ve referans el kitabı içerir. İşleyişin çoğu sadece kuralların ifade edilmesinden çok okumaya, yazmaya ve tekrar örneklerine dayalı. Çoğu kısımda örnekler ayrılmış parçalar olmaktan ziyade tamamlanmış gerçek programlar. Bütün örnekler doğrudan makine tarafından okunulabilir (\textbf{machine-readable}) formda olan metin üzerinden test edildiler. Biz, dilin etkili kullanımının nasıl olacağını göstermek dışında ayrıca mümkün olduğu yerlerde kullanışlı algoritmaları ve iyi bir tasarımın prensiplerini örneklemeyi denedik.
\par Bu kitap tanıtıcı bir programlama el kitabı değildir. Okuyucunun değişkenler (\textbf{variables}), atama ifadeleri (\textbf{statements}), döngüler (\textbf{loops}) ve fonksiyonlar (\textbf{functions}) gibi temel programlama konseptlerine biraz aşinalığı olduğunu varsayar. Yine de acemi bir programcının, daha bilgili bir iş ortağına erişmesi okuyabilmesi ve dili algılayabiliyor olmasına yardımcı olacaktır. \pagebreak

\par Bizim deneyimimizde C; kendini çok çeşitli programlar için keyifli, etkileyici ve çok yönlü bir dil olarak kanıtlamıştır. Öğrenmesi kolaydır ve sizlerden gelişen tecrübeyle hala iyi kalmayı başarıyor. Umuyoruz ki bu kitap onu iyi bir şekilde kullanmanızda yardımcı olacaktır.
\thispagestyle{prefacetofe}
\par Birçok arkadaş ve iş ortağımızın düşünceli eleştiri ve önerilerini (\textbf{suggestions}) büyük ölçüde bu kitaba ve onu yazma zevkimize kattık. Özellikle Mike Bianchi, Jim Blue, Stu Feldman, Doug McIlroy, Bill Roome, Bob Rosin, ve Larry Rosie çoklu versiyonların hepsini dikkatle okudular. Ayrıca çeşitli evrelerdeki yardımcı yorumları (\textbf{comments}) için Al Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie Haley, Marion Harris, Rick Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha, Peter Nelson, Elliot Pinson, Bill PIauger, Jerry Spivack, Ken Thompson, ve Peter Weinberger'e ve yazım düzenlemesindeki sağlam yardımları için  Mike Lesk ve Joe Ossanna'ya minnettarız.

\noindent \hspace*{270pt}{Brian W. Kernighan \\}
\hspace*{280pt}{Dennis M. Ritchie}

\mainmatter

\chapter*{Giriş}
\addcontentsline{toc}{chapter}{Giriş}

C, genel amaçlı bir programlama dilidir. C, UNIX sisteminin kendisi olduğu gibi üzerinde çalışan programların da büyük çoğunluğunun C dilinde yazılmış olmasından dolayı, geliştirildiği yer olan UNIX sistemi ile yakından ilişkilidir. Ancak dil herhangi bir işletim sistemi ve makineye bağlı değildir fakat derleyiciler (\textbf{compilers}) ve işletim sistemlerini yazmakta kullanışlı olduğu için "sistem programlama dili" olarak adlandırılmış olmasına rağmen aynı ölçüde birçok farklı alanda majör programlar yazmak için de kullanılmıştır.
\par BCPL dilinden kaynaklanan birçok C fikirlerinin çoğu Martin Richards tarafından geliştirildi. BCPL'in C'nin üzerindeki etkisi dolaylı yoldan Ken Thompson tarafından 1970'te DEC PDP-7'deki ilk "UNIX" sistemi için yazılmış olan B dili aracılığıyla geldi.
\par BCPL ve B "türsüz" (\textbf{typeless}) dillerdir. Onların aksine C, bir çok çeşit veri türü (\textbf{type}) sağlar. Temel türler karakterler, tam sayılar (\textbf{integers}), ve bazı boyuttaki ondalıklı (\textbf{floating-points}) sayılar. Ek olarak; türetilmiş veri türlerinin (\textbf{derived data types}) işaretçiler (\textbf{pointers}), diziler (\textbf{arrays}), yapılar (\textbf{structures}) ve birlikler (\textbf{unions}) ile birlikte yarattığı bir hiyerarşi vardır. Açıklamalar (\textbf{expressions}), operatörler (\textbf{operators}) ve işlenenlerden (\textbf{operands}) oluşur. Bir atama (\textbf{assignment}) veya bir fonksiyon (\textbf{function}) çağrısı içeren her açıklama (\textbf{expression}), bir ifade(\textbf{statement}) olabilir. İşaretleyiciler (\textbf{pointers}) makineden bağımsız (\textbf{machine-independent}) adres aritmetiği için sağlanıyor.
\par C, iyi yapılandırılmış programlar için gerekli olan temel kontrol akışı (\textbf{control-flow}) yapılarını sağlar: ifade (\textbf{statement}) gruplaması, karar verme (if-else), mümkün olan durumlar arasından birini seçme (switch), sonucunda döngünün bitirilip bitirilmeyeceğine karar verilen koşul testinin döngünün (\textbf{loop}) başında yapıldığı döngüler (\textbf{loop}) (while, for) veya bu koşul testinin sonunda yapılmasını sağlayan (do) ve erken döngü (\textbf{loop}) bitirmeye yarayan (break).
\par Fonksiyonlar (\textbf{functions}), temel türlerin (\textbf{type}), yapıların (\textbf{structures}), birliklerin (\textbf{unions}) veya işaretleyicilerin (\textbf{pointers}) değerini döndürebilir. \pagebreak

\thispagestyle{introduction} \noindent Her fonksiyon (\textbf{function}) birden fazla kere çağırılabilir. Yerel değişkenler (\textbf{variables}) tipik olarak "otomatiktirler", ya da her çağrı ile yeniden yaratılırlar diyebiliriz. Fonksiyonlar (\textbf{functions}) iç içe tarif edilemez (\textbf{define}) fakat değişkenler (\textbf{variables}) blok yapı (\textbf{block-structured}) tarzında deklare edilebilir. C programının fonksiyonları (\textbf{functions}) ayrı olarak derlenen ayrı kaynak dosyaları içinde bulunabilir. Değişkenler; (\textbf{variables}) bir fonskiyon (\textbf{function}) için dahili, harici fakat sadece tek bir kaynak dosyası içinde bilinen ya da tüm program için görülür olabilirler.
\par Önişleme adımı program metninde; yerine koyma makrosunu, diğer kaynak dosyalarının dahil edilmesini ve koşulsal derleme (\textbf{compilation}) işlemlerini gerçekleştirir. \newline
\par C, nispeten "düşük seviye" bir dil. Bu nitelendirme aşağılayıcı değil, sadece C'nin bilgisayarların çoğunun yaptığı nesnelerle uğraştığı anlamına geliyor, karakterler, sayılar ve adresler. Bunlar gerçek makineler tarafından uygulanan aritmetik ve mantıksal operatörler (\textbf{operators}) tarafından birleştirilebilir ve hareket ettirilebilirler. C, karakter öbekleri (\textbf{strings}), kümeler (\textbf{sets}), listeler (\textbf{lists}) ve diziler gibi bileşik objelerle uğraşmak için işlemler sağlamaz. Yapıların (\textbf{structures}) bir birim olarak kopyalanabilmesine rağmen karakter öbeklerinin (\textbf{string}) ve dizilerin (\textbf{arrays}) tamamını değiştirebilecek işlemler yoktur. C, statik tarif etme (\textbf{definition}) ve fonksiyonların (\textbf{functions}) yerel değişkenleri (\textbf{variables}) tarafından sağlanan yığın disiplini (\textbf{stack discipline}) dışında hiçbir depolama tahsis olanağı tarif etmeyen (\textbf{define}) bir dildir. Yığın ağacı (\textbf{heap}) veya çöp koleksiyonu (\textbf{garbage collection}) yoktur. Son olarak C'nin kendisi girdi/çıktı (\textbf{input/output}) olanağı sağlamaz, \textbf{READ} veya \textbf{WRITE} ifadeleri (\textbf{statements}) ve yerleşik dosya erişim metotları yoktur. Bütün bu yüksek seviye mekanizmaların ayrıca çağırılan fonksiyonlar (\textbf{functions}) tarafından sağlanması gerekir. Birçok C implementasyonu, bu fonksiyonların (\textbf{functions}) uygun bir standart koleksiyonunu içerir.
\par Benzer şekilde C sadece basit, tek iş parçacıklı (\textbf{single-thread}) kontrol akışı (\textbf{control-flow}) sunar: testler, döngüler (\textbf{loops}), gruplama ve alt programlar (\textbf{subprograms}). Fakat multi programlama (\textbf{multiprogramming}), paralel işlemler, senkronizasyon ya da eşyordamlar (\textbf{coroutines}) sunmaz. Bu özelliklerin bazılarının yokluğu ölü gereksinim gibi gözükse de ("İki karakter dizisini karşılaştırmam için bir fonksiyon (\textbf{function}) çağırmam gerektiğini mi söylemek istedin?") dili mütevazi boyutlarda tutmanın gerçek faydaları vardır. C nispeten küçük bir dil olduğundan dolayı, küçük bir alanda açıklanabiliyor ve hızlıca öğrenilebiliyor. Bir programcı mantıklı olarak, tüm dili bilmeyi, anlamayı ve gerçekten muntazam olarak kullanmayı bekleyebilir. \pagebreak

\thispagestyle{introduction} \par Yıllarca C'nin tarifi, C Programlama Dili'nin ilk tirajındaki referans el kitabı oldu. 1983'te, Amerikan Standartları Enstitüsü (\textbf{American National Standards Institute}) (\textbf{ANSI}) C'nin modern ve kapsamlı bir tarifini sağlamak için bir komite kurdu. Ortaya çıkan tarif, "ANSI standardı" ya da "ANSI C" 1988'in sonlarına doğru tamamlandı. Standardın birçok özelliği çoktan modern derleyiciler (\textbf{compilers}) tarafından desteklenmiştir.
\par Standart, orijinal referans el kitabını baz almıştır. Dil nispeten biraz değişti; standartın amaçlarından biri hali hazırda varolan programların çoğunun geçerli kalması veya bu mümkün olmazsa derleyicilerin (\textbf{compilers}) yeni davranışlar için uyarılar üretmesiydi.
\par Birçok programcı için en önemli değişim; fonksiyonları (\textbf{functions}) deklara etmek veya tarif etmek (\textbf{define}) için olan yeni sözdizimi (\textbf{syntax}). Bir fonksiyon (\textbf{function}) declara şimdi fonksiyonun (\textbf{function}) argümanlarının (\textbf{arguments}) açıklamasını içerebilir; tarif etme (\textbf{definition}) sözdizimi (\textbf{syntax}) eşleşmek üzere değişir. Bu ekstra bilgilendirme derleyicilerin (\textbf{compilers}) eşleşmeyen argümanlar (\textbf{arguments}) yüzünden ortaya çıkan hataları farketmesini daha kolay hale getirir. Bizim deneyimimizde, dile yapılan son derece kullanışlı bir ekleme.
\par Daha küçük çaplı dil değişimleri var. Geniş ölçüde mevcut olan yapı atamaları (\textbf{structure assignment}) ve numaralandırmalar (\textbf{enumerations}) şimdi resmi olarak dilin bir parçası. Kayan noktalı sayıların (\textbf{floating-point numbers}) hesaplamaları şimdi tek duyarlıklı (\textbf{single precision}) formatta yapılabilir. Aritmetiğin özellikleri, özellikle belirlenmemiş türler (\textbf{unsigned types}) için netleştirildi. Önişlemci (\textbf{preprocessor}) daha ayrıntılı. Bu değişimlerin çoğu, birçok programcı üzerinde sadece minör etkiye sahip olacaktır.
\par Standardın ikinci en önemli katkısı, C'ye eşlik etmek üzere bir kütüphanenin tarifidir (\textbf{definition}). Bu; işletim sistemine erişmek için fonksiyonlar (\textbf{functions}) (örneğin dosyaları okumak ve yazmak için), biçimlendirilmiş girdi (\textbf{input}) ve çıktı (\textbf{output}), hafıza tahsisi (\textbf{memory allocation}), karakter öbeği (\textbf{string}) manipülasyonu vb. şeyler belirtir. Standart başlıkların (\textbf{header}) koleksiyonu, fonksiyonların (\textbf{functions}) ve veri türlerinin (\textbf{data types} deklarasyonlarına tek tip erişim sağlar. Bu kütüphaneyi programların konakçı (\textbf{host}) bilgisayar ile etkileşim için kullanması, uyumlu (compatible) davranışlar sergilemelerini güvence altına almıştır. Kütüphanenin büyük bir kısmı "standart I/O kütüphanesinde" (input/output girdi/çıktı) dikkatle modellenmiştir. Bu kütüphane ilk tirajda açıklanıyor ve diğer sistemlerde de geniş ölçüde kullanılmıştır. Tekrar söylüyoruz, birçok programcı çok fazla değişim görmeyecek.
\par C tarafından sağlanan veri türleri ve kontrol yapılarının (\textbf{structures}) birçok bilgisayar tarafından doğrudan destekleniyor olması yüzünden kendine yeten programları implement etmek için gerekli olan çalışma kütüphanesi (\textbf{run-time library}) oldukça küçük. \pagebreak

\noindent \thispagestyle{introduction} Standart kütüphane (\textbf{library}) fonksiyonları (\textbf{functions}) tekli olarak çağrılıyor. Bu yüzden gerekli olmadıkları durumlarda kaçınılabiliyorlar. Çoğu, C dilinde yazılabilir ve içerdikleri işletim sistemi detayları hariç kendileri taşınabilirler (\textbf{portable}).
\par C, birçok bilgisayarın kabiliyetleri ile uyuşsa da belirli herhangi bir makine mimarisinden bağımsızdır. Biraz özenle, taşınılabilir (\textbf{portable}) programlar yazmak kolaydır. Yani değişken donanımlar üzerinde bir değişim olmadan çalışabilecek programlar. Standart, taşınılabilirlik (\textbf{portability}) sorunlarını açık hale getirmekte ve programın üzerinde çalıştırıldığı makineyi karakterize eden birtakım sabitler (\textbf{constants}) kümesini reçete etmekte.
\par C, kuvvetle-yazılmış (\textbf{strongly-typed}) bir dil değil, fakat geliştikçe, tür kontrolü (\textbf{type-checking}) de güçlendirildi (\textbf{strengthened}). C'nin orijinal tarifi, işaretleyiciler (\textbf{pointers}) ve tam sayıların (\textbf{integers}) değişimini hoş karşılamadı fakat buna izin verdi. Bu ortadan kaldırılalı uzun zaman oldu ve şimdi standart, iyi derleyiciler (\textbf{compilers}) tarafından çoktan zorunlu olan uygun deklarasyonlar ve açık dönüşümler gerektiriyor. Yeni fonksiyon (\textbf{function}) deklarasyonları bu yönde bir başka adım. Derleyiciler (\textbf{compilers}) birçok tür (\textbf{type}) hatasını bildirir ve uyumsuz veri türlerinin (\textbf{data types}) otomatik dönüşümleri yoktur. Yine de C, programcıların ne yaptığını bildiği basit felsefeyi korur, sadece onların amaçlarını açıkça bildirmelerini gerektirir.
\par C'nin de başka her dilin olduğu gibi kendi kusurları var. Operatörlerin (\textbf{operators}) bazıları yanlış önceliklere sahip. Söz diziminin (\textbf{syntax}) bazı kısımları daha iyi olabilir. Yine de C, programlama uygulamalarının geniş çeşitliliği için son derece etkili ve anlamlı bir dil olarak kendini kanıtlamıştır.
\par Bu kitap şu şekilde organize edilmiştir: Bölüm 1, C'nin merkezi kısmında öğreticidir. Biz; yeni bir dil öğrenmenin o dilde programlar yazmak olduğuna inandığımızdan dolayı amaç, mümkün olduğunca çabuk başlayan okuyucular edinmek. Öğretici kısım; programlamanın temellerinin okuyucuda bulunduğunu farz eder: Ne bilgisayarların, ne derlemenin ne de "n=n+1" gibi bir ifadenin anlamının açıklaması var. Biz mümkün olan yerlerde kullanışlı programlama tekniklerini göstermeyi denedik fakat bu kitap veri yapıları (\textbf{structures}) ve algoritmalar üzerinde referans çalışması olarak tasarlanmamıştır. Bir seçim yapmak zorunda kaldığımızda, dil üzerinde yoğunlaştık.

\par Üzerinde durulan nokta hala yalıtılmış kısımlardan ziyade tamamlanmış programların örnekleri olmasına rağmen Bölüm 2, Bölüm 6 ile beraber C'nin çeşitli yönlerini Bölüm 1'de olduğundan daha detaylı ve daha biçimsel olarak tartışıyor. Bölüm 2, temel veri türleri (\textbf{data types}), operatörler (\textbf{operators}) ve ifadeler (\textbf{statements}) ile ilgilenir. \pagebreak

\noindent \thispagestyle{introduction} Bölüm 3, kontrol akışını (\textbf{control-flow}) ele alır: if-else, switch, while, for vb. Bölüm 4, fonksiyonlar (\textbf{functions}) ve program yapılarını (\textbf{structures}) -harici değişkenler (\textbf{variables}), kapsam kuralları, çoklu kaynak dosyaları ve bunun gibi- kapsar ve ayrıca önişlemciye (\textbf{preprocessor}) değinir. Bölüm 5 işaretçileri (\textbf{pointers}) ve adres aritmetiğini tartışır. Bölüm 6 yapıları (\textbf{structures}) ve birlikleri (\textbf{unions}) kapsar.
\par Bölüm 7, işletim sistemine uygun arayüz sağlayan standart kütüphaneyi açıklar. Bu kütüphane "ANSI" standardı tarafından tarif edilmiştir (\textbf{define}) ve C'yi destekleyen tüm makinelerde desteklenmesi için yapıldı. Bu yüzden onu girdi (\textbf{input}), çıktı (\textbf{output}) ve diğer işletim sistemi erişimi için kullanan programlar, bir sistemden diğerine değiştirilmeden taşınabilir (\textbf{prtable}).
\par Bölüm 8, C programları ve UNIX işletim sistemi, girdi (\textbf{input}) ve çıktıya (\textbf{output}) odaklanma, dosya sistemi ve depolama tahsisi (\textbf{storage allocation}) arasındaki arayüzü açıklar. Bu bölümün bir kısmı özellikle UNIX sistemi için olsa da diğer sistemleri kullanan programcılar da burada standart kütüphanenin bir versiyonunun nasıl uygulandığını kavrama ve taşınılabilirlik önerileri de dahil olmak üzere kullanışlı materyaller bulabilirler.
\par Ek Bölüm A, bir dil referans el kitabı içerir. Sözdiziminin (\textbf{syntax}) ve C'nin anlambiliminin (\textbf{semantics}) resmi ifadeleri (\textbf{statements}) ANSI standardıdın kendisidir. Ancak bu belge başta derleyici (\textbf{compiler}) yazıcılara yöneliktir. Buradaki referans el kitabı dilin tarifini daha kısa ve aynı titiz, katı stil olmadan iletir. Ek Bölüm B, dahil ediciler (\textbf{implementer}) çok kullanıcılar için standart kütüphanenin bir tarifi (\textbf{definition}). Ek Bölüm C, orijinal dildeki değişimlerin kısa bir özeti. Ancak şüpheye düşüldüğünde standartın ve onun kendi derleyicisi (\textbf{compiler}), dilin son otoriteleri olarak kaldılar.

\chapter{Öğretici Kısıma Giriş}
C'ye hızlı bir girişle başlayalım. Ana odağımız dilin gerekli elemanlarını detaylara, ayrıntılara, kurallara ve istisnalara girmeden gerçek programlar aracılığıyla göstermek. Bu aşamada tamamlayıcı ve kusursuz olmaya çalışmıyoruz. Sizi, olabilecek en kısa sürede işe yarar programlar yazabilecek hale getirmeye çalışıyoruz. Ve bunu yapabilmek için temellere (değişkenler (\textbf{variables}), sabitler (\textbf{constants}), aritmetikler, kontrol akışı (\textbf{control flow}), fonksiyonlar (\textbf{functions}), girdi (\textbf{input}) ve çıktıların (\textbf{output}) esasları) odaklanmamız gerekmekte. Bilerek bu bölümde C'nin büyük programlar yazmak için önemli olan özelliklerine değinmiyoruz. Bu işaretleyiciler (\textbf{pointers}), yapılar (\textbf{structers}), C'nin zengin operatör setinin çoğunu, bazı kontrol akışı (\textbf{control-flow}) ifadelerini (\textbf{statement}) ve temel C standart kütüphanesini (\textbf{library}) içeriyor.
\par Bu amacın kendine has sakıncaları bulunmakta. En öne çıkanı ise belirli bir dilin baştan sona hikayesinin burada bulunmaması. Aynı zamanda, öğretici kısım özetleyici olduğu gibi yanıltıcı da olabilir. Ve örnekler öğretim amacıyla C'nin tüm gücünden faydalanmadığından, olabilecek en öz ve zarif şekilde değiller. Bu etkileri hafifletebileceğimiz kadar hafiflettik fakat dikkatli olmanız gerekmekte. Bir diğer sakınca ise bundan sonraki bölümlerin bu bölümün bir kısmının tekrarını içeriyor olması. Umuyoruz ki bu tekrarlama size rahatsızlıktan çok yardım sağlar.
\par Herhangi bir durumda, deneyimli programcılar kendi programcılık ihtiyaçları doğrultusunda verilen materyalden faydalanacaklardır. Yeni başlayanlar ise bunu kendi küçük benzer programlarını yazarak sağlayabilirler. İki grup da bunu çatı (\textbf{framework}) olarak Bölüm 2'de başlayan daha detaylı açıklamaların üstüne kullanabilirler. \pagebreak

\section{Başlamak}

Yeni bir programlama dili öğrenmenin tek yolu o dille programlar yazmaktır. Yazılacak ilk program tüm diller için aynıdır.
\begin{lstlisting}
		Kelimeleri Bastır
			hello, world
\end{lstlisting}
\par Bu büyük bir engel; aşılması için programı metin olarak bir yerde oluşturmak, ardından başarılı bir şekilde derlemek, yüklemek, çalıştırmak, ve çıktının (\textbf{output}) nereye gittiğini bilmek gerekiyor. Bu mekaniksel detaylarda ustalaştıktan sonra, geri kalan her şey görece daha kolay.
    \par C'de "hello, world" bastırma programı
\begin{lstlisting}
    #include <stdio.h>

        main()
        {
            printf("hello, world\n");
        }
\end{lstlisting}

Bu programı çalıştırmak kullandığınız sisteme göre değişiklik gösterir. Spesifik bir örnek vermek gerekirse, UNIX işletim sisteminde programı hello.c gibi ".c" uzantılı bir dosyanın içine kaydedip, ardından bu komut ile derlemeniz gerekir.
\begin{lstlisting}
		cc hello.c
\end{lstlisting}
Eğer bir karakter yazmayı unutmak veya bir şeyi yanlış yazmak gibi bir hata yapmadıysanız, derleme sorunsuz ve sessiz bir şekilde gerçekleşmeli, ve a.out isimli bir çalıştırılabilir (\textbf{executable}) dosya oluşmalı. Eğer bu komut ile a.out dosyasını çalıştırırsanız
\begin{lstlisting}
		a.out
\end{lstlisting}
bunu bastıracaktır
\begin{lstlisting}
		hello, world
\end{lstlisting}

Diğer sistemlerde kurallar farklı olacaktır, sisteminizle ilgili yerel bir uzmana danışın.
Şimdi programın kendisi hakkında biraz açıklama. Bir C programı, boyutu ne olursa olsun, fonksiyonlardan(\textbf{functions}) ve değişkenlerden(\textbf{variables}) oluşur. Bir fonksiyon (\textbf{function}), yapılacak bilgisayarsal operasyonları belirten ifadeler (\textbf{statements}) ve çalışma sırasında kullanılacak değerleri (\textbf{values}) taşıyan değişkenler (\textbf{variables}) içerir. C fonksiyonları (\textbf{functions}) daha çok altprogramlara (\textbf{subroutines}) ya da Fortran dilini bilenlerin aşina olduğu Fortran fonksiyonlarına (\textbf{function}), Pascal prosedürlerine (\textbf{procedures}) ve Pascal fonksiyonlarına (\textbf{functions}) oldukça benzer. Bizim örneğimiz \textbf{main} isimli fonksiyon (\textbf{function}). Normalde fonksiyonlara (\textbf{functions}) istediğiniz ismi vermekte özgürsünüz fakat "\textbf{main}" için değil. Programınız \textbf{main} fonksiyonunu (\textbf{function}) baştan aşağıya doğru çalıştırarak işe başlar. Bu, her programın herhangi bir yerinde bir \textbf{main} fonksiyonu (\textbf{function}) olmasını gerektirir.
\textbf{main} genellikle başka fonksiyonları (\textbf{functions}) gerçekleştireceği işe yardım için çağırır, bazen sizin yazdıklarınız, bazen de kütüphanelerde (\textbf{libraries}) sizin için sağlanan fonksiyonları. Programınızın ilk satırı,
\begin{lstlisting}
		#include <stdio.h>
\end{lstlisting}
derleyiciye (\textbf{compiler}) standart girdi (\textbf{input}) çıktı (\textbf{output}) hakkında bilgilerin programa dahil edilmesini söyler. Bu satır hemen hemen her C kaynak (\textbf{source}) dosyasında bulunur. Standart kütüphane (\textbf{library}) Bölüm 7'de ve Ek B'de açıklanmıştır.
Fonksiyonlar (\textbf{functions}) arasında veri aktarımı için gerekli metot, çağırılan fonksiyonlara (\textbf{functions}) argümanlar (\textbf{arguments}) adı verilen değer veya değerler vermektir. Fonksiyon adından sonraki parantezlerin arasında argüman (\textbf{argument}) veya argümanlar (\textbf{arguments}) bulunur. \\

\begin{lstlisting}
    #include <stdio.h>              standart kütüphane (library) hakkında                                 bilgileri içer
    main()                          main adında hiç argümanı (argument)
                                    olmayan bir fonksiyon (function) deklara et

    {
                                    main'in ifadeleri (statements) süslü
                                    parantezler arasındadır

        printf("hello, world\n");   main bir kütüphane (library)
                                     fonksiyonu (function) olan printf
                                     fonksiyonunu (function) parantezlerin
                                     arasında verilen argümanı ekrana
                                     bastırması için çağırıyor; \n yeni bir
    }                                satırı temsil eder.
\end{lstlisting}
\begin{center}İlk C programı.\end{center}
\pagebreak

Bu örnekte \textbf{main} fonksiyonu (\textbf{function}) hiçbir argüman (\textbf{argument}) beklemeyen bir fonksiyon (\textbf{function}) olarak deklara edildi, bu parantezler arasında hiçbir veri olmamasıyla gösterilir ().
Fonksiyonun ifadeleri (\textbf{statements}) süslü parantezler içerisinde yer alır \textbf{\{\}}. \textbf{main} fonksiyonu sadece bir ifade (\textbf{statement}) içeriyor,
\begin{lstlisting}
		printf("hello, world\n");
\end{lstlisting}
C derleyicisi (\textbf{compiler}) hata mesajı üretecektir.
\textbf{printf} asla yeni bir satırı otomatik olarak sağlamayacaktır, yani bu sayede tek bir çıktıyı (\textbf{output}) aralıksız bir biçimde printf fonksiyonunu (\textbf{function}) birden fazla kere çağırarak bastırabiliriz ve bu ilk programımız kadar iyi çalışır.

\begin{lstlisting}
		#include <stdio.h>

		main()
		{
			printf("hello, ");
			printf("world");
			printf("\n");
		}
\end{lstlisting}

Bu şekilde aynı çıktıyı (\textbf{output}) bastırabiliriz.
\textbackslash n'nin sadece bir karakteri temsil ettiğini farkedin. \textbackslash n  gibi bir kaçış dizesi (\textbf{escape sequence}) bize yazılması zor veya görünmez karakteri belirtmek için genel ve genişletilebilir bir mekanik sağlıyor. C'nin diğer sağladığı kaçış dizeleri: \textbackslash t tab karakteri için, \textbackslash b geri tuşu (\textbf{backspace}) için, \textbackslash " çift tırnak için, ve  \textbackslash \textbackslash \hspace*{1mm}ters eğik çizginin (\textbf{backslash}) kendisi için. Bunların listesinin tamamını Bölüm 2.3'te bulabilirsiniz. \\

\noindent \textbf{Egzersiz 1-1.} "hello, world" programını sisteminizde çalıştırın. Programın belli başlı parçalarını çıkartın ve alacağınız uyarı mesajlarını ve çıktıları (\textbf{outputs}) görün. \\

\noindent \textbf{Egzersiz 1-2.} printf'in argümanı (\textbf{argument}) olan karakter öbeği (\textbf{string}) burada listelenmemiş olan \textbackslash c karakterini içerdiğinde ne olacağını görün.

\section{Değişkenler ve Aritmetik Açıklamalar}

Sonraki program aşağıdaki Fahrenhayt dereceleri ve onların Selsiyus (Santigrat) eşitliklerini gösteren tabloyu bastırmak için \degree \textit{C} = (5/9)(\degree \textit{F}-32) formülünü kullanıyor. \pagebreak

\begin{lstlisting}
        0   -17
        20  -6
        40  4
        60  15
        80  26
        100 37
        120 48
        140 60
        160 71
        180 82
        200 93
        220 104
        240 115
        260 126
        280 137
        300 148
\end{lstlisting}
\par Programın kendisi hâlen sadece \textbf{main} adında tek bir fonksiyon (\textbf{function}) içeriyor. "hello, world" bastıran programdan biraz uzun ancak korkacak bir şey yok, komplike değil. Bu program bize, yorumlar (\textbf{comments}), deklarasyonlar, değişkenler (\textbf{variables}), aritmetik açıklamalar, döngüler (\textbf{loops}) ve formatlanmış çıktılar (\textbf{output}) gibi birkaç yeni fikri gösteriyor.

\begin{lstlisting}
		#include <stdio.h>

		/* Fahrenhayt-Selsiyus tablosunu bastır

			for fahr = 0, 20, ... 300 */

		main()
		{
			int fahr, celsius;
			int lower, upper, step;

			lower = 0; /* ısı tablosunun en düşük değeri */
			upper = 300; /* ısı tablosunun en yüksek değeri */
			step = 20; /* adım değeri */

			fahr = lower;

			while (fahr <= upper) {
				celsius = 5 * (fahr-32) / 9;
				printf("%d\t%d\n", fahr, celsius);
				fahr = fahr + step;
			}
		}
\end{lstlisting}
Bu iki satır \begin{lstlisting}
		/* Fahrenhayt-Selsiyus tablosunu bastır

			for fahr = 0, 20, ... 300 */
\end{lstlisting}
bu durumda programın nasıl çalıştığını, programın kaynak (\textbf{source}) kodunu okuyanlara açıklayan \textit{yorum} (\textbf{comment}) satırlarıdır. \textbf{/*} ve \textbf{*/} karakterleri arasında olan karakterler derleyici (\textbf{compiler}) tarafından görmezden gelinir, bu satırlar programı okurken anlamayı daha kolay hale getirmek için özgürce kullanılabilir. Yorum satırları boşluk, tab veya yeni satır karakterinin koyulabileceği bütün yerlere koyulabilirler.
\par C'de; bütün değişkenler (\textbf{variables}) kullanılmadan önce deklara edildi. Genellikle fonksiyonun (\textbf{function}) başında bütün çalıştırılabilir ifadelerden (\textbf{executable statements}) önce deklara edilmeli. Bir deklarasyon değişkenlerin (\textbf{variables}) özelliklerini anons eder; bu anons değişkenlerin (\textbf{variables}) deklare edilecek olan türünü (\textbf{type}) ve değişkenlere (\textbf{variable}) verilecek adları içerir, örneğin
\newline
\begin{lstlisting}
		int fahr, celsius;
		int lower, upper, step;
\end{lstlisting}
tür(\textbf{type}) \textbf{int} kendisinin ardından listelenen değişkenlerin (\textbf{variable}) birer tamsayı (\textbf{integer}) olduğunu belirtir. Kayar noktalı yani ondalıklı sayılar (\textbf{float}) ile karşılaştırırsak, \textbf{int} ve \textbf{float}'un da sahip olduğu aralık, kullandığınız makineye dayalıdır; 16-bit \textbf{int'ler}, -32768 ve +32767 arasındadır ve 16-bit \textbf{int'ler} de 32-bit \textbf{int'ler} kadar yaygındır, çoğunlukla \textbf{float} sayı 32-bit niceliğindedir, bu en az 6 farklı basamağa ve $10^{-38}$ ve $10^{+38}$ arasında bir büyüklüğe tekabül eder.
\par C \textbf{int} ve \textbf{float}'un yanında birkaç başka temel veri türü (\textbf{type}) daha sağlıyor:

\begin{lstlisting}
        char    karakter - tek byte
        short   kısa tamsayı (integer)
        long    uzun tamsayı (integer)
        double  64-bit (double precision) ondalıklı (float)
\end{lstlisting}
Bu objelerin büyüklüğü de makineye dayalı (\textbf{machine-dependent}). Bunların yanında kurs boyunca tanışacağımız dizeler (\textbf{arrays}), yapılar (\textbf{structers}) ve birlikler (\textbf{unions}) gibi basit türler (\textbf{types}); onları işaretlemek (\textbf{pointing}) için işaretleyiciler (\textbf{pointers}) ve onları döndürmek (\textbf{return}) için fonksiyonlar (\textbf{functions}) vardır. \pagebreak
\par Isı birimi dönüşümü programında hesaplama atama (\textbf{assignment}) ifadeleriyle (\textbf{assignment statements}) başlıyor.
\begin{lstlisting}
        lower = 0;
        upper = 300;
        step = 20;
        fahr = lower;
\end{lstlisting}
Bu ifadeler (\textbf{statement}) ile değişkenler (\textbf{variables}) başlangıç değerlerine ayarlıyor. Tekli (toplu değil, bireysel) ayarlanmak istenen değişkenler (\textbf{variables}) noktalı virgül ile bitiriliyor.
\par Tablonun her satırı aynı şekilde hesaplanıyor, bu yüzden her çıktı (\textbf{output}) satırı için bunu tekrarlayabiliriz; işte \textbf{while} döngüsünün (\textbf{loop}) amacı budur.
\begin{lstlisting}
        while (fahr <= upper) {
            ...
        }
\end{lstlisting}
\textbf{while} döngüsü (\textbf{loop}) şöyle işliyor: Parantezler arasındaki koşul test edilir, eğer koşul doğru ise (\textbf{fahr} küçüktür veya eşittir \textbf{upper}'a), döngünün (\textbf{loop}) gövdesi (süslü parantezler arasındaki bölüm) çalıştırılır. Ardından koşul tekrardan test edilir ve eğer doğru ise, gövde tekrardan çalıştırılır. Koşul testi sırasında yanlış sonuç ortaya çıkarsa (\textbf{fahr} büyüktür \textbf{upper}'dan) gövde çalıştırılmaz ve döngü (\textbf{loop}) sona erer. Ve programın çalışması döngüden (\textbf{loop}) sonrası için olan ifadelerle(\textbf{statement}) devam eder. Bu programda döngüden sonra bir ifade (\textbf{statement}) yoktu ve bu yüzden program sona erdi.
\par \textbf{while}'ın gövdesi süslü parantezler arasında bir veya birden çok ifade (\textbf{statement}) içerebilir veya süslü parantezler olmadan tek bir ifade (\textbf{statement}) içerebilir, örneğin;
\begin{lstlisting}
        while (i < j)
            i = 2 * i;
\end{lstlisting}
Her koşulda, her zaman ifadeleri (\textbf{statements}) bir tab (4 boşluk) ile girintileyeceğiz. Bu şekilde sizler göz gezdirirken hangi ifadelerin (\textbf{statement}) döngünün (\textbf{loop}) içinde olduğunu rahatlıkla görebileceksiniz. Girintileme programın mantıksal yapısını öne çıkartır. Buna karşın C derleyicisi (\textbf{compiler}) programın nasıl gözüktüğünü umursamaz, düzgün girintileme ve boşluklama sadece programların insanlar için daha okunabilir olması içindir. Buna karşın insanların girintileme için bazı tutkulu düşünceleri var. Biz popüler tarzlar arasından birini seçtik. Size uygun olanı seçmekten çekinmeyin ve sürekli kullanın. \pagebreak
\par İşin çoğu döngünün (\textbf{loop}) gövde kısmında gerçekleşiyor. Celcius ısı birimi hesaplanıyor ve \textbf{celcius} adında bir değişkene (\textbf{variable}) ifade (\textbf{statement}) tarafından atanıyor.
\begin{lstlisting}
        celsius = 5 * (fahr-32) / 9;
\end{lstlisting}
Sadece 5/9 ile çarpmak yerine 5 ile çarpılıp ardından 9'a bölünmesinin sebebi C'de ve diğer bir çok dilde, tam sayıların (\textbf{integer}) bölümlerinin kesirli (ondalıklı) kısımlarının budanması. 5 ve 9 tamsayı (\textbf{integer}) olduğundan, 5/9'un sonucunun kesirli kısmı budanırdı, geriye sadece 0 kalırdı ve tüm Selsiyus ısıları 0 olarak raporlanırdı.

\par Bu örnek \textbf{printf}'in nasıl çalıştığını biraz daha gösteriyor. \textbf{printf} Bölüm 7'de detaylı açıklayacağımız genel amaçlı çıktı (\textbf{output}) formatlama fonksiyonudur (\textbf{function}). İlk argümanı, (\textbf{argument}) bastırılacak karakter öbeğidir (\textbf{string}), her \% karakterinin yeri, fonksiyona (\textbf{function}) girilen bir diğer argüman (\textbf{argument}) tarafından yeri doldurulur; (ikinci, üçüncü, ...) argümanlar (\textbf{arguments}) \% karakterlerinin yerine geçerler. Örneğin, \textbf{\%d} bir tamsayı (\textbf{integer}) argümanı (\textbf{argument}) belirtir. Böylelikle ifade
\begin{lstlisting}
        printf("%d\t%d\n", fahr, celsius);
\end{lstlisting}
iki tam sayının (\textbf{integer}) değerlerin (\textbf{values}) yani \textbf{fahr} ve \textbf{celcius}'un aralarında tab(\textbackslash t) karakteri ile bastırılmasını sağlar.
\par Her \% karakteri \textbf{printf}'in ilk argümanından (\textbf{argument}) sonraki uyan ilk argümanıyla (\textbf{argument}) eşleşir. Argümanlar (\textbf{arguments}) ve \% karakterleri birbiriyle tür (\textbf{type}) olarak ve sıralama olarak eşleşmeli, yoksa yanlış çıktı alırsınız.
\par Bu arada \textbf{printf} C dilinin bir parçası değil: C'nin kendisinde girdi (\textbf{input}) ve çıktı (\textbf{output}) tarif edilmemiştir (\textbf{define}). \textbf{printf} sadece standart girdi (\textbf{input}) çıktı (\textbf{output}) kütüphanesinde (\textbf{library}) bulunan yararlı bir fonksiyon (\textbf{function}). \textbf{printf}'in davranışı ANSI standartında belirlenmiştir, böylelikle özellikleri her derleyiciyle (\textbf{compiler}) ve kütüphaneyle (\textbf{library}) standarta uyar.
\par C'nin kendisine odaklanmak için, girdi (\textbf{input}) ve çıktı (\textbf{output}) hakkında Bölüm 7'den önce çok konuşmayacağız. Özellikle, o zamana dek formatlanmış girdiye (\textbf{input}) değinmeyeceğiz. Eğer numaraları girdilemeniz (\textbf{input}) gerekiyorsa, \textbf{scanf} fonksiyonu (\textbf{function}) üzerine olan Bölüm 7.4'ü okuyunuz. \textbf{scanf}, \textbf{printf} gibi, sadece çıktı yazmak yerine girdi okuyor. \pagebreak
\par Isı birimi dönüştürme programında birtakım problemler var. Bu problemlerden daha basit olanı çıktının (\textbf{output}) pek güzel olmaması, çünkü sayılar tam yerinde değil. Bunu düzeltmesi kolay; her \% karakterini \textbf{printf} ifadesinde (\textbf{statement}) bir genişlik ile yazarsak, sayılar alanlarında olması gereken yerlerinde olacaktır.
Örneğin
\begin{lstlisting}
        printf("%3d %6d\n", fahr, celsius);
\end{lstlisting}
ilk sayıyı 3 basamak genişliğinde, ikinci sayıyı da 6 basamak genişliğinde üstteki gibi bastırırsak:
\begin{lstlisting}
          0        -17
         20         -6
         40          4
         60         15
         80         26
        100         37
        120         48
        140         60
        160         71
        180         82
        200         93
        220        104
        240        115
        260        126
        280        137
        300        148
\end{lstlisting}
\par Daha ciddi olan problem ise tam sayı (\textbf{integer}) aritmetiği kullandığımızdan dolayı Selsiyus ısıları tam olarak doğru değil; örneğin, 0\degree F aslında -17.8\degree C, -17 değil. Daha doğru çıktıları (\textbf{output}) almamız için tamsayı (\textbf{integer}) yerine ondalıklı (\textbf{float}) aritmetik kullanmalıyız. Bu, programda bazı değişiklikleri gerektiriyor. İşte programın ikinci versiyonu: \pagebreak

\begin{lstlisting}
        #include <stdio.h>

        /* Fahrenhayt-Selsiyus tablosunu bastır

            for fahr = 0, 20, ... 300 */

        main()
        {
            float fahr, celsius;
            int lower, upper, step;

            lower = 0; /* ısı tablosunun en düşük değeri */
            upper = 300; /* ısı tablosunun en yüksek değeri */
            step = 20; /* adım değeri */

            fahr = lower;

            while (fahr <= upper) {
                celsius = (5.0/9.0) * (fahr-32.0)
                printf("%3.0f\t%6.1f\n", fahr, celsius);
                fahr = fahr + step;
            }
        }
\end{lstlisting}
\par Bu öncekine çok benziyor, tek farkı \textbf{fahr}'ın ve \textbf{celsius}'un ondalıklı sayı (\textbf{float}) olarak deklare edilmiş olması ve dönüşüm için kullanılan formülün daha doğal şekliyle yazılmış olması. 5/9'u önceki versiyonda kullanamıyorduk çünkü iki tam sayının (\textbf{integer}) bölümü ondalıklı kısmını budayarak sonucun 0 çıkmasını sağlıyordu. Bir sabitteki (\textbf{constant}) ondalık noktası o sabitin türünün (\textbf{type}) ondalıklı sayı (\textbf{float}) olduğunu belirtir, yani 5.0/9.0 budanmadı çünkü işlem iki ondalıklı sayı (\textbf{float}) ile yapıldı.
\par Eğer aritmetik operatörün tam sayı (\textbf{integer}) işlenenleri (\textbf{operands}) olursa tam sayılarla (\textbf{integers}) gerçekleşen bir işlem yapılırdı. Eğer aritmetik operatörün bir ondalıklı sayı (\textbf{float}) ve bir tam sayı (\textbf{integer}) işleneni (\textbf{operand}) var ise bir şey farketmez ve tam sayı (\textbf{integer}) işlemden önce ondalıklı sayıya (\textbf{float}) dönüştürülür ve ardından hesaplama yapılırdı. Eğer \textbf{fahr-32} yazmış olsaydık, \textbf{32} otomatikman ondalıklı sayıya (\textbf{float}) dönüştürülürdü. Yine de ondalıklı sayı (\textbf{float}) olan sabitleri tam (\textbf{integral}) olmalarına rağmen ondalık noktasını kullanarak yazmamız, onların ondalıklı sayı (\textbf{float}) doğasını insan okuyucular için vurgular. Tam sayıların (\textbf{integer}) ondalıklı sayılara (\textbf{float}) dönüşümlerinin detaylarını Bölüm 2'de göreceğiz.


\pagebreak Şuanlık şu atamayı (\textbf{assignment}) farkedin
\begin{lstlisting}
        fahr = lower;
\end{lstlisting} ve test edin.
\begin{lstlisting}
        while (fahr <= upper)
\end{lstlisting} İkisi de çalışıyor, \textbf{int} operasyondan önce \textbf{float}'a dönüştürülüyor ve ardından hesaplama yapılıyor.

\par \textbf{printf} dönüşümü belirteçi \textbf{\%3.0f} ondalıklı sayının (\textbf{floating-point number}) (burada fahr) en az 3 karakter genişliğinde, ondalık noktası ve kesir basamağı olmadan bastırılmasını belirtiyor. \textbf{\%6.1f} diğer bir sayı olan \textbf{celcius}'un  en az 6 karakter genişliğinde ve ondalık noktasından sonra sadece bir kesir basamağı olacak şekilde bastırılmasını belirtiyor.
Çıktı (\textbf{output}) şöyle gözüküyor:
\begin{lstlisting}
          0      -17.8
         20       -6.7
         40        4.4
         60       15.6
         80       26.7
        100       37.8
        120       48.9
        140       60.0
        160       71.1
        180       82.2
        200       93.3
        220      104.4
        240      115.6
        260      126.7
        280      137.8
        300      148.9
\end{lstlisting}

Genişlik ve nicelik bir belirteçle görmezden gelinebilir: \textbf{\%6f} sayının en az 6 karakter genişliğinde olmasını belirtiyor; \textbf{\%.2f} ondalık noktasından sonraki iki karakteri temsil ediyor fakat genişlik zoraki değil ve \textbf{\%f} sayıyı ondalıklı sayı (\textbf{float}) olarak bastırmasını belirtiyor. \pagebreak

\begin{lstlisting}
        %d          tamsayı(integer) olarak bastır

        %6d         tamsayı(integer) olarak bastır, 6 karakter genişliğinde

        %f          ondalıklı sayı(float) olarak bastır

        %6f         ondalıklı sayı(float) olarak bastır, 6 karakter
                    genişliğinde

        %.2f        ondalıklı sayı(float) olarak bastır, ondalık
                    noktasından sonra sadece iki karakter

        %6.2f       ondalıklı sayı(float) olarak bastır, en az 6 karakter
                    genişliğinde ve ondalık noktasından sonra iki karakter
\end{lstlisting} Diğerlerininin yanında, \textbf{printf} ayrıca \textbf{\%o} belirtecini sekizlikler(\textbf{octal}), \textbf{\%x} onaltılıklar(\textbf{hexademical}) için, \textbf{\%c}'yi karakterler için, \textbf{\%s}'yi karakter öbekleri(\textbf{string}) için, ve \textbf{\%\%}'yi \%'ün kendisi için kullanıyor. \\

\noindent \textbf{Egzersiz 1-3.} Isı birimi dönüşüm programını tablonun başındaki yorum satırlarındaki başlığı bastıracak şekilde düzenleyin. \\


\noindent \textbf{Egzersiz 1-4.} Tablodakileri bastıracak benzer bir programı yardım almadan kendiniz yazın.

\section{For Döngüsü (loop)}

\par Bir programı belirli bir görevi gerçekleştirmesi için çok farklı şekillerde yazabiliriz. Haydi ısı dönüşüm programının bir varyasyonunu oluşturalım.

\begin{lstlisting}
		#include <stdio.h>

        /* Fahrenhayt-Selsiyus tablosu bastır */
        main()
        {
            int fahr;

            for (fahr = 0; fahr <= 300; fahr = fahr + 20)
                printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
        }
\end{lstlisting}

Bu da aynı çıktıyı (\textbf{output}) üretecektir, fakat kesinlikle farklı gözüküyor.

\pagebreak En büyük değişiklik birçok değişkenin (\textbf{variables}) saf dışı bırakılması; sadece \textbf{fahr} kaldı ve onu bir \textbf{int} yaptık. \textbf{lower} ve \textbf{upper} limitleri ve adım büyüklüğü sadece \textbf{for} ifadesi (\textbf{statement}) içinde sabit (\textbf{constant}) olarak karşımızda, artık yeni bir inşâ ve Selsiyus sıcaklığını hesaplayan açıklama ayrı bir ifade (\textbf{statement}) yerine artık \textbf{printf}'nin üçüncü argümanı (\textbf{argument}) olarak karşımızda.

\par Bu son değişiklik bize bir türün (\textbf{type}) değişkeni (\textbf{variable}) yerine doğrudan değer (\textbf{değer}) kullanmamıza izin verilmesi durumuna bir örnek, bu durumlarda o türün (\textbf{type}) daha komplike açıklamaları kullanılabilir. \textbf{printf}'in üçüncü argümanı \textbf{\%6.1f} ile eşleşecek olan bir ondalıklı sayı (\textbf{float}) olması gerektiğinden herhangi bir ondalıklı sayı (\textbf{float}) oraya konulabilir.
\par \textbf{for} ifadesi (\textbf{statement}) bir döngü (\textbf{loop}), \textbf{while}'ın bir genellemesi. Eğer erken (\textbf{earlier}) \textbf{while} ile karşılaştırırsak, işleyişi açıkça görebiliriz. Parantezler içerisinde noktalı virgüller ile ayrılan üç ayrı bölüm mevcut. İlk bölüm, deklarasyon:
\begin{lstlisting}
		fahr = 0
\end{lstlisting}
Döngü (\textbf{loop}) başlamadan önce sadece bir kere yapılır. İkinci bölüm ise test veya döngüyü (\textbf{loop}) kontrol edecek olan koşul bölümüdür:
\begin{lstlisting}
		fahr <= 300
\end{lstlisting}
Bu koşul değerlendirilir; eğer doğru ise, döngünün (\textbf{loop}) gövde (\textbf{body}) kısmı (burada sadece \textbf{printf}) çalıştırılır. Ardından arttırma bölümü
\begin{lstlisting}
		fahr = fahr + 20
\end{lstlisting}
çalıştırılır ve koşul tekrardan test edilir. Döngü (\textbf{loop}) eğer koşul yanlış (\textbf{false}) olursa sonlanır. \textbf{while}'da olduğu gibi gövde (\textbf{body}) kısmı tek bir ifadeden (\textbf{statement}) veya süslü parantezler arasındaki ifade (\textbf{statements}) gruplarından oluşabilir. Tanımlama, koşul ve arttırma bölümleri herhangi bir açıklamadan (\textbf{expression}) oluşabilir.
\par \textbf{while} ve \textbf{for} arasındaki seçim isteğe bağlı, hangisi gereken durum için daha temiz görünüyorsa onu kullanın. \textbf{while}'dan daha kompakt olduğundan ve döngü (\textbf{loop}) kontrol ifadelerini (\textbf{statements}) beraber tek bir yerde tuttuğundan, \textbf{for} genellikle deklarasyo ve arttırmanın tek bir ifade olduğu ve mantıksal olarak ilişkili olduğu döngüler (\textbf{loop}) için daha uygundur. \newline
\\ \noindent \textbf{Egzersiz 1-5.} Isı dönüşüm programını tabloyu tersine bastıracak şekilde düzenleyin, 300 dereceden 0'a doğru. \pagebreak

\section{Sembolik Sabitler (constants)}

\par Isı dönüşümünü sonsuza dek bir kenara bırakmadan önce son bir gözlem yapalım. Programa 300 ve 20 gibi "sihirli sayılar" gömmek kötü; bu sayılar bu programı daha sonra okuyacak bir kişinin kolayca görmek ve değiştirmek istediği değerler (\textbf{values}) taşıyorlar, bu sayıları bu şekilde gömmek onları sistematik yolla değiştirmeyi zorlaştırdığı gibi hangi sayının neye ait olduğunu da bilmemizi zorlaştırıyor. Bu sihirli sayılarla ilgilenmenin bir yolu onlara anlamlı isimler vermek. \textbf{\#define} satırı belirli bir karakter öbeğini bir sembolik isim veya sembolik sabit (\textbf{constant}) olarak tarif eder:
\begin{lstlisting}
		#define isim(name) karakter öbeği
\end{lstlisting}
Daha sonra programda herhangi bir yerde bu isim (\textbf{name}) geçtiğinde, isim (\textbf{name}) ile eşleşen karakter öbeği (\textbf{string}) ismin yazıldığı yere geçer. İsmin (\textbf{name}) formu değişkenlerin (\textbf{variables}) adlarının formuyla aynıdır: bir harf ile başlayan, sayı ve harflerden oluşan dizi. Eşleşen karakter öbeği her türlü karakterden oluşabilir, sadece sayılarla sınırlı değildir.
\begin{lstlisting}
		#include <stdio.h>

		#define    LOWER    0          /* tablonun en düşük limiti */
		#define    STEP     20		   /* adım büyüklüğü */
		#define    UPPER    300        /* en yüksek limiti */

		/* Fahrenhayt-Selsiyus tablosunu bastır */
		main ()
		{
			int fahr;

			for(fahr = LOWER; fahr <= UPPER; fahr += STEP) {
				printf("%3d\t%6.1f\n", fahr, (5.0/9.0)*(fahr-32));
			}

		}
\end{lstlisting}

\textbf{LOWER}, \textbf{UPPER} ve \textbf{STEP} nicelikleri birer sembolik sabittir (\textbf{constant}), değişken (\textbf{variables}) değil; bu yüzden deklarasyonlarla yapılmıyorlar. Sembolik sabitler (\textbf{constant}) genellikle büyük harflerle yazılır böylece kolayca küçük harfli değişken (\textbf{variable}) adlarından ayırt edilebilirler. \textbf{\#define} satırının sonunda noktalı virgül olmadığını farkedin. \pagebreak

\section{Karakter Girdisi (input) ve Çıktısı (output)}

Artık karakter verisi işleyecek, birbiriyle alakalı bir program ailesini konuşacağız. Birçok programın, sadece buradaki prototiplerin genişletilmiş versiyonları olduğunu farkedeceksiniz.
\par Standart girdi (\textbf{input}) çıktı (\textbf{output}) kütüphanesinin (\textbf{library}) desteklediği girdi (\textbf{input}) çıktı (\textbf{output}) modeli oldukça basit. Metin girdisi (\textbf{input}) ve çıktısı (\textbf{output}); nereden kaynaklandığı ve nereye gittiği farketmeksizin, karakter akıntıları (\textbf{stream of charachters}) ile yapılır. \textit{Metin akıntısı} (\textbf{text stream}) satırlara bölünmüş bir karakter dizisidir; her satır sıfır veya daha fazla karakterden ve onları takiben gelen bir yeni satır karakterinden oluşur. Her girdi (\textbf{input}) ve çıktı (\textbf{output}) akışını bu modele uydurmak kütüphanenin (\textbf{library}) sorumluluğunda; C programcısı kütüphaneyi satırların program dışında nasıl temsil edildiği hakkında endişelenmemek için kullanıyor.
\par Standart kütüphane (\textbf{library}) bize bir kerede bir adet karakter yazdırmak için birçok fonksiyon sağlıyor, \textbf{getchar} ve \textbf{putchar} en basitleri. Her çağrıldığında \textbf{getchar} bir sonraki girdi (\textbf{input}) karakterini metin akışından okuyor ve onu kendi değeri (\textbf{value}) olarak döndürüyor (\textbf{return}). Değişken (\textbf{variable}) c
\begin{lstlisting}
		c = getchar()
\end{lstlisting}
bir sonraki girdi (\textbf{input}) karakterini içerir. Karakterler genelde klavyeden gelir; dosyalardan girdileri (\textbf{input}) Bölüm 7'de konuştuk.
\textbf{putchar} fonksiyonu (\textbf{function}) her çağrıldığında bir karakteri bastırıyor:
\begin{lstlisting}
		putchar(c)
\end{lstlisting}
Tam sayı olan değişken (\textbf{variable}) c'yi karakter olarak bastırıyor, genellikle ekrana. \textbf{putchar} ve \textbf{printf} çağrıları belki iç içe geçmiş olabilir, çıktı (\textbf{output}) yapılan çağrıya göre ortaya çıkacaktır. \pagebreak

\subsection{Dosya Kopyalama}

Bilinen \textbf{getchar} ve \textbf{putchar} ile, girdi (\textbf{input}) ve çıktı (\textbf{output}) dışında başka bir şey bilmeden şaşırtıcı derecede fazla yararlı kod yazabiliriz. En basit örnek girdiyi (\textbf{input}) çıktıya (\textbf{output}) bir kerede bir karakter olarak kopyalayan program:
\begin{lstlisting}
		karakteri oku
		while (karakter dosya-sonu göstergesi değil)
			okuduğun karakteri çıktıla(output)
			karakter oku
\end{lstlisting}
Bunu C'ye dönüştürürsek:
\begin{lstlisting}
		#include <stdio.h>

		/* girdiyi (input) çıktıya (output) kopyala; 1. versiyon */
		main()
		{
			int c;

			c = getchar();
			while (c != EOF) {
				putchar(c);
				c = getchar();
			}
		}
\end{lstlisting}
Mantıksal bir operatör olan \textbf{ !=} "eşit değil" anlamına gelir.
\par Tabiki ekrandaki yada klavyedeki karakter, diğer her şey gibi, bit olarak içeride saklanıyor. Tür (\textbf{type}) \textbf{char} özellikle karakter verisi taşıması için oluşturuldu fakat herhangi bir tam sayı (\textbf{integer}) değer kullanılabilir. Biz ince ve önemli bir sebeple \textbf{int} kullandık.
\par Problem, girdinin (\textbf{input}) sonunun geçerli veriden ayırılması. Çözüm ise \textbf{getchar}'ın girdi (\textbf{input}) kalmadığında herhangi gerçek bir karakterle karıştırılamayacak belirgin bir değer dönmesi (\textbf{return}). Bu değer \textbf{EOF} olarak adlandırılıyor, "dosya sonu" (\textbf{end of file}) anlamına geliyor. Biz c'yi \textbf{getchar}'ın döndürebileceği kadar büyük bir değer taşıyan bir türde deklare etmemiz gerekiyor. c, lazım olduğunda EOF'yi taşıyabileceği kadar büyük olması gerektiğinden \textbf{char} kullanamazdık. Bu nedenle \textbf{int} kullandık.
\par EOF \textbf{<stdio.h>}'da bir tam sayı (\textbf{integer}) olarak tarif edilmiştir (\textbf{define}), fakat EOF'nin sayı değeri hakkında \textbf{char} değeri ile aynı olmadığından dolayı endişelenmemiz gerekmiyor. Sembolik sabiti (\textbf{Symbolic Constant}) kullanarak, programdaki hiçbir şeyin belirli bir sayı değerine dayalı olmadığından emin olduk.
\par Kopyalama programı tecrübeli C programcıları tarafından daha farklı yazılabilir. C'de herhangi bir atama (\textbf{assignment}), örneğin
\begin{lstlisting}
		c = getchar()
\end{lstlisting}
bir açıklamadır (\textbf{expression}) ve değeri vardır, eşitliğin sol tarafindekinin değeri atamadan (\textbf{assignment}) sonra belirlenir. Böylece bir atama (\textbf{assignment}) daha geniş bir açıklamanın bir parçası olabilir. Eğer c'nin bir karaktere atanması \textbf{while} döngüsünün test kısmının içerisine konulursa, kopyalama programı bu şekilde yazılabilir:
\begin{lstlisting}
		#include <stdio.h>

		/* girdiyi (input) çıktıya (output) kopyala; 2. versiyon */

		main()
		{
			int c;

			while ((c = getchar()) != EOF)
				putchar(c);
		}
\end{lstlisting}

\textbf{while} karakteri alıyor, c'ye atıyor, ve karakterin dosya-sonu (\textbf{end-of-file}) sinyali olmadığı koşulunu test ediyor. Eğer değilse, \textbf{while}'ın gövde (\textbf{gövde}) kısmı çalıştırılıyor ve karakter bastırılıyor. Sonra \textbf{while} tekrar ediyor. Ve girdinin sonuna ulaşıldığında, \textbf{while} sona eriyor ve ardından tabiki \textbf{main} de.

\par Bu versiyon girdiyi (\textbf{input}) merkezleştiriyor - artık sadece tek \textbf{getchar}'a tek bir referans var - ve programı kısaltıyor. Son program çok daha kompakt, ve bu kullanımda ustalaştıkça, okumak da daha kolay. Bu tarzı çok sık göreceksiniz. (bunu biraz abartmak ve anlaşılmaz kodlar yazmak mümkün, bu kendimizi tutmamız gereken bir eğilim.)

\par Atamanın etrafındaki koşulun içindeki parantezler gerekli.  !='in \textit{önceliği} (\textbf{precedence})  ='den yüksek, bu yüzden parantezler olmasaydı mantıksal test olan  != atama (\textbf{assignment}) olan  ='den önce yapılırdı. \\ \pagebreak

Bu yüzden ifade (\textbf{statement})

\begin{lstlisting}
		c = getchar() != EOF
\end{lstlisting}
eşittir
\begin{lstlisting}
		c = (getchar() != EOF)
\end{lstlisting}
Bunun \textbf{getchar}'ın dosya-sonu (\textbf{end-of-file}) sinyaline ulaşıp ulaşmadığına göre c'yi ya 0'a yada 1' atamak (\textbf{assignment}) gibi bir istenmeyen etkisi var. (Bölüm 2'de bununla ilgili fazlası var.) \newline
\noindent \textbf{Egzersiz 1-6.} Açıklama (\textbf{expression}) getchar() != EOF'nin 0'a yada 1'e eşit olduğunu doğrulayın.
\newline
\noindent \textbf{Egzersiz 1.7.} EOF'in değerini bastıran bir program yazın.

\subsection{Karakter Sayma}

Bir sonraki program karakterleri sayıyor; kopyalama programına oldukça benziyor.
\begin{lstlisting}
		#include <stdio.h>
		/* girdideki (input) karakterleri say; 1. versiyon */
		main()
		{
			long nc;

			nc = 0;
			while (getchar() != EOF)
				++nc;
			printf("%ld\n", nc);
		}
\end{lstlisting}
\par İfade (\textbf{statements})
\begin{lstlisting}
		++nc;
\end{lstlisting}
yeni bir operatörü bize tanıtıyor, ++, \textit{bir ile arttır} anlamına geliyor. Bunun yerine nc = nc+1 yazabilirdiniz fakat ++nc çok daha kısa ve çoğunlukla daha verimli. Bu operatörün eşi -- operatörü ise bir ile azalt anlamına geliyor. ++ ve -- operatörleri önek (\textbf{prefix}) (++nc) veya arkak (\textbf{postfix}) (nc++) olabilirler; bu ki formun Bölüm 2'de göstereceğimiz gibi açıklamalarda (\textbf{expressions}) farklı değerleri olur, fakat hem nc++ hem ++nc de nc'yi birer arttıracaktır. Şuanlık sadece önek (\textbf{prefix}) formunu kullanacağız..
\par Karakter sayma programı sayımlarını \textbf{int} yerine \textbf{long} bir değişken (\textbf{variable}) içinde biriktirir. \textbf{long} tam sayılar (\textbf{integer}) en az 32 bit olsa da bazı makinelerde \textbf{long} ve \textbf{int} aynı boyuttadır, diğerlerinde ise \textbf{int} maksimum değeri 32767'dir ve 16 bit yer kaplar. Bu sebeple \textbf{int} bir sayacı geçmek oldukça az girdi (\textbf{input}) gerektirecektir. Dönüşüm özelliği (\textbf{conversion spesification}) \textbf{\%ld} \textbf{printf}'e eşleşecek olan argümanın (\textbf{argument}) bir \textbf{long} tam sayı (\textbf{integer}) olacağını söyler.
\par Bundan bile daha büyük sayılarla bile başa çıkmak ise \textbf{double} (double precision float) ile mümkündür. Ayrıca döngü (\textbf{loop}) yazmanın bir diğer yolunu göstermek için \textbf{while} ifadesi (\textbf{statement}) yerine de \textbf{for} ifadesi kullanacağız.
\begin{lstlisting}
		#include <stdio.h>

		/* girdideki (input) karakterleri say; 2. versiyon */
		main()
		{
			double nc;

			for (nc = 0; getchar() != EOF; ++nc)
				;
			printf("%.0f\n", nc);
		}
\end{lstlisting}
\textbf{printf} \textbf{\%f}'i hem \textbf{float} hem de \textbf{double} için kullanıyor; \textbf{\%0.f} ise ondalık noktasını ve bu programda her zaman 0 olan kesirli kısmın bastırılmamasını sağlıyor.
\par Bu \textbf{for} döngüsünün (\textbf{loop}) gövde (\textbf{body}) kısmı boş, çünkü bütün iş koşul ve arttırma bölümleri tarafından yapılıyor. Fakat C'nin gramatik kuralları gereği \textbf{for} ifadesinin (\textbf{statement}) bir gövdesi olması gerek. Yalnız duran noktalı virgül, \textit{boş ifade} (\textbf{null statement}) olarak adlandırılır, bu C'nin bu gerekliliğini sağlamak için kullanılır. Bunu daha görünür yapmak için ayrı bir satıra koyduk.
\par Karakter sayma programını bir kenara bırakmadan önce, eğer girdi (\textbf{input}) hiç karakter içermiyorsa, \textbf{while} veya \textbf{for} daha \textbf{getchar}'ı ilk çağırışta sona eriyor, ve program doğru sonuç olan 0 sonucunu üretiyor. Bu önemli. \textbf{while} ve \textbf{for} ile ilgili güzel şeylerden biri ise, daha döngünün (\textbf{loop}) gövde (\textbf{body}) kısmına başlamadan önce koşul bölümünü test ediyor olmaları. Eğer yapılacak bir şey yoksa, hiçbir şey yapılmıyor, bu döngünün (\textbf{loop}) gövde (\textbf{body}) kısmının asla çalıştırılmayacak olduğu anlamına gelse bile. Programlar onlara sıfır-uzunlukta girdi (\textbf{input}) verildiğinde zekice haraket etmelidirler. \textbf{while} ve \textbf{for} ifadeleri (\textbf{statements}) en ekstrem (sınır, limit) koşullarda bile programların mantıklı şeyler yapmasından emin oluyor.

\subsection{Satır Sayma}

Bir sonraki program girdideki (\textbf{input}) satırları sayıyor. Daha önce belirttiğimiz gibi, standart kütüphane, girdi (\textbf{input}) metin akışının satır dizeleriyle ortaya çıkmasını sağlıyor, her satır bir yeni satır karakteri ile bitiyor. Bu yüzden satırları saymak ile yeni satır karakterlerini saymak aynı şey:

\begin{lstlisting}
		#include <stdio.h>

		/* girdiden (input) satır say  */
		main()
		{
			int c, n1;

			n1 = 0;
			while ((c = getchar()) != EOF)
				if (c == '\n')
					++n1;

			printf("%d\n", n1);

		}
\end{lstlisting}

\textbf{while}'ın gövde kısmı şuan \textbf{if}'ten oluşuyor, burada \textbf{if}, ++n1 artışını kontrol ediyor. \textbf{if} ifadesi kendisini takiben gelen (\textbf{statement}) parantezler içerisindeki koşulu test ediyor, ve koşul doğru (\textbf{true}) ise, ifadeyi (\textbf{statement}) (veya süslü parantezler içerisindeki bir grup ifadeyi çalıştırıyor. Neyin ne tarafından kontrol edildiğini göstermek için yine girintiledik.
\par Çift eşittir \textbf{==} gösterimi "eşit mi" anlamına gelen bir C notasyonudur (Pascal'ın tek ='i veya Fortran'ın .EQ.'sı gibi). Bu sembol eşitlik testini C'de atama (\textbf{assignment}) için kullanılan tek \textbf{=}'den ayırmak için kullanıldı. Biraz uyarı: C'ye yeni başlayanlar ara sıra \hspace{1mm} \textbf{==}'i kast etmelerine rağmen \hspace{1mm} \textbf{=} yazıyorlar. Bölüm 2'de göreceğimiz üzere bunun sonucu geçerli bir açıklama (\textbf{expression}) oluyor ve bir uyarı almıyorsunuz.
\par Tek tırnak arasına yazılan karakter, makinenin karakter setindeki, karakterin numerik değerine eşit olan bir tamsayıyı (\textbf{integer}) temsil ediyor. Bu \textit{karakter sabiti} (\textbf{character constant}) olarak adlandırılıyor, buna rağmen bu sadece küçük bir tamsayı (\textbf{integer}) yazmanın bir diğer yolu. Örneğin, \textbf{'A'} bir karakter sabiti (\textbf{character constant}); ASCII karakter setindeki değeri 65, bu, karakter \textbf{A}'nın içerideki temsili. Tabiki \textbf{'A'} 65'in üzerinde bir değer olarak tercih edilebilir: bunun anlamı açık, ve belirli bir karakter setinden bağımsız.
\par Karakter öbeği sabitlerinde (\textbf{string constants}) kullanılan kaçış dizelerinin (\textbf{escape sequences}) kullanımı da geçerli, yani \textbf{'\textbackslash n'} yeni satır karakterinin değerini temsil ediyor, ASCII'de bu değer 10. \textbf{\textbackslash n}'in tek bir karakter olduğunu farketmeniz gerekiyor, ve bu açıklama (\textbf{expression}) sadece bir tamsayı (\textbf{integer}); bir diğer deyişle, \textbf{"\textbackslash n"} sadece tek bir karakter içeren bir karakter öbeği sabiti (\textbf{string constant}). Karakter öbeklerinin (\textbf{string}) ve karakterlerin farklarına Bölüm 2'nin sonlarında bahsedeceğiz. \newline

\noindent \textbf{Egzersiz 1-8.} Boşlukları, tableri, ve yenı satırları sayan bir program yazınız. \newline

\noindent \textbf{Egzersiz 1-9.} Girdisini (\textbf{input}) çıktısına (\textbf{output}) kopyalayan bir program yazınız, her karakter öbeğindeki (\textbf{string}) birden fazla olan boşlukları tek boşlukla değiştirecek. \newline

\noindent \textbf{Egzersiz 1-10.} Girdisini (\textbf{input}) çıktısına (\textbf{output}) kopyalayan bir program yazınız, her tabi \textbackslash t ile, her geri tuşunu \textbackslash b ile ve her ters eğik çizgiyi \textbackslash \textbackslash ile değiştirecek. Bu tableri, ters eğik çizgiyi ve geri tuşu karakterlerini daha açık bir yolla gösterecek.

\subsection{Kelime Sayma}

\par Yararlı programlar serimizdeki dördüncü program, gevşek bir tarif ile (\textbf{definition}) boşluk, tab veya yeni satır içermeyen her karakter sekansını kelime olarak saymakla birlikte satırları ve karakterleri sayıyor. \pagebreak

\noindent Bu bir UNIX programı olan \textbf{wc}'nin oldukça temel bir hali.

\begin{lstlisting}
		#include <stdio.h>

		#define IN	1	/* kelimenin içinde  */
		#define OUT 0	/* kelimenin dışında */

		/* girdideki (input) satırları, kelimeleri ve karakterleri say  */
		main ()
		{
			int c, n1, nw, nc, state;

			state = OUT;
			n1 = nw = nc = 0;
			while((c = getchar()) != EOF) {
				++nc;
				if (c == '\n')
					++n1;
				if (c == ' ' || c == '\n' || c == '\t')
					state = OUT;
				else if (state == OUT) {
					state = IN;
					++nw;
				}
			}
			printf("%d %d %d\n", n1, nw, nc);
		}
\end{lstlisting}
\par Program her bir kelimenin ilk harfi ile karşılaştığında bir kelime daha sayıyor. Değişken (\textbf{variable}) \textbf{state} programın anlık olarak bir kelimenin içinde mi yoksa dışında mı olduğunu kaydediyor; başlangıçta "kelimenin içinde değil" yani OUT'un değerine atanıyor. Biz, gerçek sayılar olan 0 ve 1 yerine IN ve OUT olan sembolik sabitleri (\textbf{symbolic constants}) kullanmayı tercih ediyoruz çünkü bu programı daha okunabilir bir hale getiriyor. Bu gibi küçük programlara oldukça az fark yaratıyor, fakat daha büyük programlarda, programın berraklığındaki artış programın en başından beri sadece mütevazi bir eforla bu şekilde yazmaya değer. Ayrıca programda geniş değişiklikler yapmanın önemli sayıların sadece sembolik sabitler (\textbf{symbolic constants}) olarak ortaya çıkmasıyla daha kolay olduğunu göreceksiniz. \pagebreak
\par Bu satır
\begin{lstlisting}
		n1 = nw = nc = 0;
\end{lstlisting}
üç değişkeni (\textbf{variable}) de 0'a atıyor. Bu özel bir durum değil, fakat bu durumun sonucu oluşan, bir değerle beraber bir açıklama (\textbf{expression}) olan bir atama (\textbf{assignment}) ve atamalar (\textbf{assignments}) sağdan sola doğru bağlanır. Bu şekilde yazmışız gibi
\begin{lstlisting}
		n1 = (nw = (nc = 0));
\end{lstlisting}
Operatör (\textbf{operator}) \textbf{||} yada (\textbf{OR}) anlamına gelir, yani bu satır
\begin{lstlisting}
		if (c == ' ' || c == '\n' || c == '\t')
\end{lstlisting}
şunu söylüyor "c bir boşluk veya c bir yeni satır veya c bir tab ise". (Kaçış dizesi (\textbf{escape sequence}) olan \textbackslash t'nin tab karakterinin görünür temsili olduğunu belirtelim) VE'nin (\textbf{AND}) yerine geçen bir operatör var \&\&; ve önceliği ||'den büyük. \&\& veya || ile bağlanan açıklamalar (\textbf{expressions}) soldan sağa doğru değerlendirilir, ve değerledirmenin yanlış (\textbf{false}) olma sonucuna ulaştığı bilindiğinde duracağı garanti edilmiştir. Eğer c boşluk ise, c'nin yeni satır veya tab olup olmadığını test etmeye gerek yoktur, bu yüzden bu testler yapılmaz. Bunun burada bir önemi yok, fakat yakında göreceğimiz daha komplike durumlarda önem arz ediyor.
\par Örnek, eğer \textbf{if}'in koşulu yanlış (\textbf{false}) çıkarsa alınacak aksiyonları belirten \textbf{else}'i gösteriyor. Genel form şu şekilde
\begin{lstlisting}
		if (açıklama (*\textit{(expression)}*))
			(* $ ifade_1$ $(statement_1) $ *)
		else
			(* $ ifade_2$ $(statement_2) $ *)

\end{lstlisting}
\noindent İki ifadenin (\textbf{statement}) tek ilişkisi \textbf{if-else}'in gerçekleşmesidir. Eğer açıklama (\textbf{expression}) doğru (\textbf{true}) ise, $ ifade_1 $ (\textbf{$ statement_1 $}) çalıştırılır, eğer doğru değil ise, $ ifade_2 $ ($ statement_2 $) çalıştırılır. Her ifade (\textbf{statement}) tek veya süslü parantezler içerisinde birden fazla olabilir. Kelime sayma programında, \textbf{else}'den sonraki if süslü parantez içerisinde iki ifadeyi (\textbf{statement}) kontrol ediyor. \newline

\noindent \textbf{Egzersiz 1-11.} Kelime sayma programını nasıl test ederdin ? Eğer programda hatalar varsa bunları ortaya çıkaracak girdi (\textbf{input}) türleri nelerdir ? \newline
\newline \textbf{Egzersiz 1-12.} Satır başı tek kelime bastıracak bir program yazınız.

\section{Diziler (arrays)}

Her rakamın kaç kere yazıldığını, boşluk karakterleri (boşluk, tab, yeni satır) ve diğer tüm karakterleri sayan bir program yazalım. Bu yapmacık, fakat bize C'nin bir çok yönünü tek bir programda göstermemizi sağlayacak.
\par Programımızda girdinin (\textbf{input}) 12 farklı kategorisi var, bu yüzden her rakamın kaç kere yazıldığını bir dizide (\textbf{array}), 10 farklı değişken (\textbf{variable}) kullanmaktan çok daha uygun. İşte programın bir versiyonu:
\begin{lstlisting}
		#include <stdio.h>

		/* rakamları, boşlukları ve diğerlerini say  */

		main()
		{
			int c, i, nwhite, nother;
			int ndigit[10];

			nwhite = nother = 0;
			for (i = 0; i < 10; ++i)
				ndigit[i] = 0;

			while ((c = getchar()) != EOF)
				if (c >= '0' && c <= '9')
					++ndigit[c-'0'];
				else if (c == ' ' || c == '\n' || c == '\t')
					++nwhite;
				else
					++nother;

			printf("digits =");
			for (i = 0; i < 10; ++i)
				printf(" %d", ndigit[i]);
			printf(", white space = %d, other = %d\n",
					nwhite, nother);
		}
\end{lstlisting}
Programa girdi (\textbf{input}) olarak kendi kaynak kodu verildiğinde çıktısı (\textbf{output})
\begin{lstlisting}
		digits = 9 3 0 0 0 0 0 0 0 1, white space = 126, other = 358
\end{lstlisting}
Tanımlama (\textbf{decleration})
\begin{lstlisting}
		int ndigit[10];
\end{lstlisting}
\textbf{ndigit}'i 10 tamsayıdan (\textbf{integer}) oluşan biri dizi (\textbf{array}) olarak deklare ediyor. \pagebreak


\noindent Dizilerin (\textbf{arrays}) alt elemanları (\textbf{subscripts}) C'de her zaman 0 ile sayılmaya başlanır, Yani elemanlar bu şekildedir \textbf{ndigit[0], ndigit[1], ..., ndigit[9]}. Bu, dizileri (\textbf{arrays}) başlatan ve onları bastıran \textbf{for} döngülerinde (\textbf{loop}) gösterilmiştir.
\par Eleman (\textbf{subscript}) herhangi bir tamsayı (\textbf{integer}) açıklama (\textbf{expression}) olabilir, i gibi tamsayı (\textbf{integer}) değişkenleri (\textbf{variables}) ve tamsayı (\textbf{integer}) sabitleri (\textbf{constants}) gibi.
\par Bu program rakamların karakter temsillerinin özelliklerine dayanıyor. Örneğin, bu test
\begin{lstlisting}
		if (c >= '0' && c <= '9')
\end{lstlisting}
c'nin içindeki karakterin bir rakam olup olmadığını belirliyor. Eğer öyle ise, o rakamın numerik değeri
\begin{lstlisting}
		c - '0'
\end{lstlisting}
\noindent Bu sadece '0', '1', ..., '9' gibi ardışık değerlerde çalışıyor. Neyse ki bu bütün karakter setleri için geçerli.
\par Tanımları gereği \textbf{char}'lar sadece küçük tamsayılar (\textbf{integer}), yani \textbf{char} değişkenleri (\textbf{variables}) ve sabitleri (\textbf{constants}) aritmetik açıklamalarda (\textbf{expressions}) \textbf{int} olarak tanınırlar. Bu gayet doğal ve kullanışlı; örneğin \textbf{c-'0'}, 0 ve 9 arasında c içinde saklanan '0' ile '9' arasındaki bir karakter ile eşleşen bir tamsayı (\textbf{integer}) açıklaması (\textbf{expression}), bu nedenle \textbf{c-'0'} \textbf{ndigit} dizisi (\textbf{array}) için geçerli bir eleman (\textbf{subscript}).
\par Karakterin bir rakam mı, yoksa bir boşluk karakteri mi, veya başka bir şey mi olduğu bu sekans ile yapılıyor
\begin{lstlisting}
		if (c >= '0' && c <= '9')
			++ndigit[c-'0'];
		else if (c == ' ' || '\n' || c == '\t')
			++nwhite;
		else
			++nother;
\end{lstlisting}
Bu desen
\begin{lstlisting}
		if ((* $ koşul_1 $ (\textbf{condition})*))
			(* $ ifade_1 $ (\textbf{statement})*)
		else if ((* $ koşul_2 $ (\textbf{condition})*))
			(* $ ifade_2 $ (\textbf{statement})*)
		...
			...
		else
			(*$ifade_n $ (\textbf{statement})*)
\end{lstlisting}
sıklıkla karşımıza çok yönlü kararların açıklandığı programlarda çıkıyor. Koşullar (\textbf{conditions}) yukarıdan aşağıya bir koşul (\textbf{condition}) doğru olana kadar değerlendiriliyor; bu noktada eşleşen \textit{ifade} (\textbf{statement}) kısmı çalıştırılır, ve bütün yapı (\textbf{construction}) biter. (Her \textit{ifade} (\textbf{statement}) süslü parantezler içerisinde birden fazla olabilir.) Eğer hiçbir koşul (\textbf{condition}) sağlanmazsa, eğer varsa \textbf{else}'den sonraki \textit{ifade} (\textbf{statement}) çalıştırılır. Eğer son \textbf{else} ve \textit{ifade} (\textbf{statement}) atlanırsa, kelime sayma programında yapıldığı gibi, herhangi bir aksiyon alınmaz. \textbf{if} ve son \textbf{else} arasında
\begin{lstlisting}
		else if ( (* $koşul$ (\textbf{condition}) *) )
			(* \textit{ifade} (\textbf{statement}) *)
\end{lstlisting}
sayısız grup olabilir.
\par Tarz gereği, yapıyı (\textbf{construction}) gösterdiğimiz formatta yazmanız önerilir; eğer her \textbf{if} \textbf{else}'den önce girdilenirse kararlardan uzun bir sekans sayfanın sağ tarafına doğru kayacaktır.
\par \textbf{switch} ifadesi (\textbf{statement}), Bölüm 3'de anlatılacaktır, \textbf{switch}, koşul (\textbf{condition}), bir sabitler (\textbf{constants}) setiyle eşleşen bir tamsayı (\textbf{integer}) veya karakter açıklaması (\textbf{expresion}) olduğunda kullanımı özellikle uygun olan bir diğer çok yönlü dal (\textbf{branch}) yazmamıza olanak sağlıyor. Karşılaştırmak için bu programın \textbf{switch} versiyonunu Bölüm 3.4'de göstereceğiz. \newline


\noindent \textbf{Egzersiz 1-13.} Girdisindeki (\textbf{input}) kelimelerin uzunluğunun bir histogramını basan bir program yazınız. Yatay barlarla bir histogram çizmek oldukça kolay; dikey dizilim çok daha zorlu olacaktır. \newline


\noindent \textbf{Egzersiz 1-14.} Farklı karakterlerin sıklığının bir histogramını bastıran bir program yazınız.

\section{Fonksiyonlar (functions)}

C'de, fonksiyonlar (\textbf{function}) Fortran'daki altprogramların (\textbf{subroutines}) veya fonksiyonların (\textbf{functions}) veyahut Pascal'daki prosedürlerin (\textbf{procedure}) veya fonksiyonların (\textbf{function}) denkidir. Bir fonksiyon (\textbf{function}), bir hesaplamayı daha sonra kendi implementasyonunda hakkında endişelenilmeden kullanmak üzere barındırmak için kullanışlı bir yol sağlar. Uygun şekilde düzenlenen fonksiyonlarla (\textbf{functions}), işin \textit{nasıl} gerçekleştirildiğini görmezden gelmek mümkün; sadece \textit{ne} yapıldığını bilmek yeterlidir. C, fonksiyonların (\textbf{functions}) kullanımını kolay, kullanışlı ve verimli hale getiriyor; sıklıkla kısa bir fonksiyonun (\textbf{function}) tarif edildiğini (\textbf{define}) ve sadece küçük bir parça kodu içerdiğinden sadece bir kere çağırıldığını (\textbf{call}) göreceksiniz.
\par Bu zamana kadar sadece \textbf{printf}, \textbf{getchar}, ve \textbf{putchar} gibi bize sağlanan fonksiyonları (\textbf{functions}) kullandık; artık birkaçını kendimizin yazma vakti geldi. C'nin Fortran'ın \textbf{**}'ı gibi bir üsalma operatörü olmadığından, fonksiyon (\textbf{function}) tarifinin (\textbf{definition}) mekaniklerini göstermek için \textbf{power(m,n)} fonksiyonunu, m tamsayısının (\textbf{integer}) n kuvvetini hesaplamak ve bunu göstermek için yazalım. Bu, \textbf{power(2,5)}'in değerini 32 yapar. Bu fonksiyon (\textbf{function}), sadece küçük tamsayıların (\textbf{integer}) pozitif değerleriyle hesap yapabildiğinden pratik bir bir üsalma rutini değil, fakat bu gösterimi yapmamız için yeterli. (Standart kütüphane (\textbf{library}) \textbf{pow(x,y)} adında \textbf{$x^y$}'yi hesaplayan bir fonksiyon (\textbf{function}) içeriyor.)
\par İşte, fonksiyon (\textbf{function}) \textbf{power} ve onu çalıştırması için main programı, bu sayede bütün yapıyı (\textbf{structure}) bir arada görebilirsiniz.
\begin{lstlisting}
		#include <stdio.h>

		int power(int m, int n);

		/* power fonksiyonunu test et */
		main()
		{
			int i;

			for (i = 0; i < 10; ++i)
				printf("%d %d %d\n", i, power(2,i), power(-3,i));
			return 0;
		}

		/* power: base sayısını n'inci kuvvetine yükselt; n >= 0 */
		int power(int base, int n)
		{
			int i ,p;

			p = 1;
			for (i = 1; i <= n; ++i)
				p = p * base;
			return p;
		}
\end{lstlisting}
Fonksiyon (\textbf{function}) tarif etmek (\textbf{definition}) böyle bir forma sahip:
\begin{lstlisting}
		dönüş-türü fonksiyon-adı(parametre deklarasyonları, eğer varsa)
		{
			deklarasyonlar
			ifadeler (* \textit{(statements)} *)
		}
\end{lstlisting}
dönüş-türü (\textbf{return-type}) fonksiyon (\textbf{function}) \pagebreak \\
\noindent Fonksiyon tarifleri (\textbf{definition}) herhangi bir şekilde bulunabilir, bir kaynak (\textbf{source}) dosyasında veya birden fazlasında, buna karşın hiçbir fonksiyon (\textbf{function}) dosyalar arasında bölünemez. Eğer kaynak (\textbf{source}) program birden fazla dosya halinde bulunuyorsa, belki tek dosya halinde bulunandan daha fazla derleyip (\textbf{compile}) yükleyecek (\textbf{load}) olduğunuzu söyleyebilirsiniz fakat bu bir işletim sistemi konusu, dilin bir niteliği değil. Şu anlık, iki fonksiyonun (\textbf{function}) da aynı dosya içinde bulunduğunu farz ediyoruz, bu yüzden şuana kadar C programlarının çalışması hakkında öğrendiğiniz her şey hala geçerli.
\par Fonksiyon (\textbf{function}) \textbf{power}, \textbf{main} tarafından iki kere çağırılıyor, bu satırda
\begin{lstlisting}
		printf("%d %d %d\n", i, power(2,i), power(-3,i));
\end{lstlisting}
her çağırma, her defasında formatlanıp bastırılacak olan bir tam sayı (\textbf{integer}) döndüren \textbf{power}'a iki argüman geçiriyor. Açıklamada \textbf{power(2,i)} aynı i ve 2 gibi birere tamsayı (\textbf{integer}). (Her fonksiyon (\textbf{function}) bir tamsayı (\textbf{integer}) değeri üretmez; bunu Bölüm 4'de konuşacağız.)
\par \textbf{power}'ın kendisinin ilk satırı:
\begin{lstlisting}
		int power(int base, int n)
\end{lstlisting}
parametre türlerini (\textbf{type}), adlarını ve fonksiyonun (\textbf{function}) döndüreceği sonucun türünü (\textbf{type}) deklare ediyor. \textbf{power} tarafından parametreleri için kullanılan isimler \textbf{power}'a yereldir (\textbf{local}), ve bir değer fonksiyon (\textbf{function}) tarafından görünebilir değildir: diğer rutinler aynı ismi bir çakışma yaşanmadan kullanabilirler. Bu aynen i ve p değişkenleri (\textbf{variable}) için de geçerli; \textbf{power} içindeki i ile \textbf{main} içindeki i tamami ile ilişkisiz.
\par Biz genellikle \textit{parametre}'yi fonksiyon (\textbf{function}) tarifinde (\textbf{definition}) parantezler içerisindeki listede adlandırılmış değişkenler (\textbf{variable}) için, argümanı ise fonksyon çağırımı (\textbf{call}) sırasında kullanılan değerler (\textbf{value}) için kullanacağız. \textit{biçimsel} (\textbf{formal}) argümanın ve \textit{asıl} (\textbf{actual}) argümanın koşulları bazen aynı ayrımı yapmak için kullanılır.
\par \textbf{power}'ın hesapladığı değer, \textbf{return} ifade (\textbf{statement}) tarafından \textbf{main}'e döndürüldü. \textbf{return}'ü takip eden herhangi bir açıklama:
\begin{lstlisting}
		return açıklama (*\textit{(expression)} *)
\end{lstlisting}
Bir değer döndürmesine gerek olmayan fonksiyonda: bir açıklaması (\textbf{expression}) olmayan \textbf{return} ifadesi (\textbf{statement}) kontrolü sağlar, fakat çağırıcı (\textbf{caller}) tarafından kullanılacak kullanışlı bir değeri (\textbf{value}) değil, fonksiyonu (\textbf{function}) sonlandıran sağ süslü paranteze ulaşarak fonksiyonun (\textbf{function}) "sonuna düşmek" ile olduğu gibi. Ve çağırılan fonksiyon (\textbf{function}), fonksiyon (\textbf{function}) tarafından döndürülen (\textbf{return}) değeri (\textbf{value}) görmezden gelebilir.
\par \textbf{main}'in sonunda bir \textbf{return} ifadesi (\textbf{statement}) olduğunu farketmişsinizdir.  \textbf{main} diğerleri gibi bir fonksiyon (\textbf{function}) olduğundan dolayı, o da çağıranına (\textbf{caller}) bir değer gönderebilir, bu da programın çalıştırıldığı çevreyi (\textbf{environment}) etkileyebilir. içeriği sıfır olan bir \textbf{return} değeri (\textbf{value}) normal bitişi (\textbf{termination}); sıfır-olmayan değerler (\textbf{values}) ise sinyal alışılmadık (\textbf{unusual}) veya hata (\textbf{erroneous}) bitirme koşullarıdır (\textbf{conditions}). Bu noktadan önce basitlik uğruna, \textbf{main} fonksiyonlarımızdaki (\textbf{function}) \textbf{return} ifadesini (\textbf{statement}) atladık, fakat bundan böyle artık onları da dahil edeceğiz, bir hatırlatma olarak, programların durumlarını çevrelerine (\textbf{environment}) döndürmelerinin (\textbf{return}) iyi olacağını belirtelim.
\par \textbf{main}'den hemen önceki bu deklarasyon
\begin{lstlisting}
		int power(int m, int n);
\end{lstlisting}
\textbf{power}'ın iki \textbf{int} argüman bekleyen ve int döndüren (\textbf{return}) bir fonksiyon (\textbf{function}) olduğunu söylüyor. \textit{fonksiyon prototipi} olarak adlandırılan bu deklarasyon, \textbf{power}'ın tarifi (\textbf{definition}) ve kullanımı konusuna açıklık getirmek zorunda. Bu fonksiyonun (\textbf{function}) tarifi (\textbf{function}) veya herhangi bir kullanımı ile prototipi arasında bir uyuşmazlık var ise bu hataya sebep olur.
\par Parametre isimlerinin uyuşmasına gerek yok. Aslında parametre isimleri fonksiyon prototipi için opsiyonel, yani prototip için bunu da yazabilirdik
\begin{lstlisting}
		int power(int, int);
\end{lstlisting}
Güzel çizilen isimler güzel dökümantasyon sağlar, her nasılsa, onları sıklıkla kullanacağız.

\par Tarih notu: ANSI C ve daha önceki versiyonlar arasındaki en önemli fark, fonksiyonların nasıl tarif (\textbf{definition}) edildiği ve deklara edildiğidir. C'nin orijinal tarifinde (\textbf{definition}), \textbf{power} fonksiyonu bu şekilde yazılmalıydı:
\begin{lstlisting}
		/* power: base sayısını n'inci kuvvetine yükselt; n >= 0 */
		/*		  (eski-stil versiyon) */
		power(base, n)
		int base, n;
		{
			int i, p;

			p = 1;
			for (i = 1; i <= n; ++i)
				p = p * base;
			return p;
		}
\end{lstlisting}
Parametreler parantezler arasında isimlendiriliyordu, ve onların türleri (\textbf{type}) açılan sol süslü parantezden önce deklara ediliyor; deklara edilmemiş (\textbf{undeclared}) parametreler \textbf{int} olarak alınıyordu. (Fonksiyonun gövdesi önceki ile aynı)
\par Eski stilde \textbf{power}'ın deklarasyonu böyle gözükmeliydi:
\begin{lstlisting}
		int power();
\end{lstlisting}
Parametre listesine izin verilmiyordu, bu yüzden derleyici (\textbf{compiler}) \textbf{power}'ın doğru çağırılıp çağırılmadığını kolayca kontrol edemiyordu. Aslında, varsayılan olarak \textbf{power}'ın \textbf{int} döndüreceği (\textbf{return}) farzedildiğinden, tüm deklarasyon işlemi atlanabilirdi.
\par Fonksiyon prototiplerinin yeni sözdizimi (\textbf{syntax}) derleyicinin (\textbf{compiler}) hataları ve argümanların sayılarını veya onların türlerini (\textbf{types}) tespit etmesini oldukça kolaylaştırıyor. Eski stil deklarasyon ve tarif etme (\textbf{definition}) ANSI C'de halen çalışıyor, en azından bir geçiş periyodu için, fakat eğer destekleyen bir derleyiciniz (\textbf{compiler}) varsa yeni formu kullanmanızı şiddetle tavsiye ediyoruz. \\


\textbf{Egzersiz 1-15.} Bölüm 1.2'nin ısı dönüşüm programını dönüşüm için bir fonksiyon kullanmak üzere yeniden yazınız.

\section{Argümanlar - Değer ile Çağırma}

C fonksiyonlarının bir yönü başka programlama dillerini, özellikle Fortran'ı kullanmış olan programcılara yabancı gelebilir. C'de, bütün fonksiyon argümanları "değerleriyle" (\textbf{by value}) geçirilir. Bu, çağırılan (\textbf{call}) fonksiyona, fonksiyonun argümanlarına verilmiş değerlerin (\textbf{value}), orijinallerinden ziyade, geçici değişkenler (\textbf{variables}) olarak verilmesidir. Bu, bizi "referans ile çağır" (\textbf{call by reference}) kullanan Fortran gibi veya \textbf{var} parametreleri içeren Pascal gibi dillerden farklı özellikler getiriyor, bu gibi dillerde çağırılan (\textbf{call}) rutinin yerel bir kopyadan ziyade, orijinal argümana erişimi var.
\par Ana değişiklik, C'de çağırılan (\textbf{call}) fonksiyonun direkt olarak çağırılan fonksiyondaki değişkende (\textbf{variable}) bir değişiklik yapamamasıdır; sadece kendi özel, geçici kopyasını değiştirebilir.
\par Değer ile çağır (\textbf{call by value}) bir varlık (asset), ancak, bir yükümlülük değil. Bu, daha az fazladan değişken (\textbf{variable}) ile daha kompakt programları sağlıyor, çünkü çağırılan (\textbf{call}) rutinde parametrelere, sıradan şekilde ilklendirilmiş (\textbf{initialize}) yerel değişkenler gibi davranılabiliyor. Örneğin, \textbf{power}'ın bu özelliği kullanan bir versiyonu. \pagebreak
\begin{lstlisting}
		/* power: base sayısını n'inci kuvvetine yükselt; n >= 0; versiyon 2 */
		int power(int base, int n)
		{
			int p;

			for (p = 1; n > 0; --n)
				p = p * base;
			return p;
		}
\end{lstlisting}
Parametre n, geçici bir değişken (\textbf{variable}) olarak kullanılıyor, ve geriye doğru sayılıyor (\textbf{for} döngüsü (\textbf{loop}) geriye doğru çalışıyor, sıfır olana kadar; artık değişken (\textbf{variable}) i'ye ihtiyaç yok. \textbf{power}'ın içinde n'ye ne yapıldıysa \textbf{power}'ın çağırıldığı argüman üstünde hiçbir etkisi yok.
\par Gerektiğinde, çağırılan (\textbf{call}) rutindeki bir değişkeni (\textbf{variable}) değiştirmek üzere bir fonksiyon yapılabilir. Çağıran, değişkenin (\textbf{variable}) yazılacak bir \textit{adresini} sağlamalı (teknik olarak değişkeni (\textbf{variable}) işaret eden bir \textit{işaretleyici} (\textbf{pointer})), ve çağırılan (\textbf{call}) fonksiyon parametrenin bir işaretleyici (\textbf{pointer}) olduğunu deklara etmeli ve değişkene (\textbf{variable}) bunun üzerinden direkt olarak erişmeli. İşaretleyicileri (\textbf{pointer}) Bölüm 5'de konuşacağız.
\par Diziler (\textbf{array}) için hikaye farklı. Bir dizinin (\textbf{array}) adı argüman olarak kullanıldığında, fonksiyona geçen değer, dizinin (\textbf{array}) başlangıcının konumu veya adresi - dizi (\textbf{array}) elemanların bir kopyalanma seçeneği yok. Bu değerin (\textbf{value}) yardımıyla, fonksiyon bir dizinin (\textbf{array}) her elemanına erişip değiştirebilir. Bu bir sonraki bölümün konusu.

\section{Karakter Dizileri (arrays)}

C'deki en yaygın dizi (\textbf{array}) tipi, karakter dizileridir (\textbf{array}). Karakter dizilerinin (\textbf{array}) ve onları manipüle etmek için kullanılan fonksiyonları göstermek üzere, bir grup metin satırı okuyarak aralarından en uzun olanı bastıran bir program yazalım. Programın dış hatları bu kadar basit:
\begin{lstlisting}
		while (başka bir satır var)
			if (bu satır bir önceki en uzun satırdan daha uzun)
				satırı kaydet
				satırın uzunluğunu kaydet
		print en büyük satır
\end{lstlisting} \pagebreak

\noindent Bu dış hatlar, programın doğal olarak ayrılacağı parçaları açığa kavuşturuyor. Bir parça yeni bir satır alıyor, bir diğeri test ediyor, bir diğeri kaydediyor, ve kalanı işlemi kontrol ediyor.
\par Bunlar güzelce parçalara ayırıldığından, bunları aynı şekilde yazmak da güzel olacak. Buna uygun olarak, bir sonraki girdi (\textbf{input}) satırını okuyacak \textbf{getline} isimli ayrı bir fonksiyon yazalım. Fonksiyonu farklı şartlar altında da yararlı olacak şekilde yazmaya çalışacağız. En basiti, \textbf{getline} olası bir dosya sonu (\textbf{end of file}) durumunda bir sinyal döndürmeli (\textbf{return}); daha kullanışlı bir tasarım satırın uzunluğunu, veya dosya sonu (\textbf{end of file}) ile karşılaşıldığında zero döndürürdü Sıfır kabul edilebilir bir \textbf{end-of-file} döndürülüşü çünkü sıfır geçerli bir satır uzunluğu değil. Her metin satırı en azından bir karaktere sahip; yeni satır karakteri içeren bir satırın bile uzunluğu 1.
\par Bir önceki en uzun satırdan daha uzun bir satır bulduğumuzda, bu satır bir yere kaydedilmeli. Bu bize bir diğer yazmamız gerekn fınksiyonu öneriyor, yeni satırı başka bir yere kopyalamak için \textbf{copy} fonksiyonu.
\par Sonunda, \textbf{getline} ve \textbf{copy} fonksiyonlarını kontrol etmesi için bir main programına ihtiyacımız var. Sonuç burada. \footnote{\noindent Çevirmenden not: \\ \indent \textbf{getline} fonksiyonu, kitabın yazıldığı süreçte olmasa da artık bir GNU/POSIX eklentisi olduğundan standart kütüphaneye (\textbf{library}) dahil edildi. Bu yüzden kitabın orjinalinde olduğu gibi \textbf{getline} fonksiyonu aynı isimle kullanılırsa derleme (\textbf{compile}) sırasında çakışma (\textbf{conflict}) hatası verecektir. gcc'yi -ansi gönderiyle (\textbf{flag}) (gcc -ansi test.c şeklinde) çalıştırmak sorunu çoğu sistemde çözse de MacOS ve BSD sistemlerde bilinmez bir nedenle işe yaramadığından fonksiyonun adını kaynak kodunda \textbf{getline2} olarak değiştirmeyi uygun görsek de metin içerisinde metnin orijinalliği esasında \textbf{getline} olarak kullanmaya devam etmeyi daha uygun gördük.} \pagebreak
\enlargethispage{2\baselineskip}
\begin{samepage}
\begin{lstlisting}
		#include <stdio.h>
		#define MAXLINE 1000 /* maksimum girdi (input) satır büyüklüğü */

		int getline2(char line[], int maxline);
		void copy(char to[], char from[]);

		/* girdideki en uzun satırı bastır */
		main ()
		{
			int len;			/* tedavüldeki satırın uzunluğu */
			int max;			/* görülen en uzun satırın uzunluğu */
			char line[MAXLINE];		/* tedavüldeki satır */
			char longest[MAXLINE];	/* en uzun satır burada kaydediliyor */

			max = 0;
			while ((len = getline2(line, MAXLINE)) > 0)
				if (len > max) {
					max = len;
					copy(longest, line);
				}
			if (max > 0)	/* satır vardı */
				printf("%s", longest);
			return 0;
		}

		/* getline2: s'deki satırı oku, uzunluğunu döndür (return) */
		int getline2(char s[], int lim)
		{
			int c, i;

			for (i=0; i<lim-1 && (c=getchar())!=EOF && c!='\n'; ++i)
				s[i] = c;
			if (c == '\n') {
				s[i] = c;
				++i;
			}
			s[i] = '\0';
			return i;
		}

		/* copy: from'dan to'ya kopyala; yeterince büyük olduğunu farz et */
		void copy(char to[], char from[])
		{
			int i;

			i = 0;
			while ((to[i] = from[i]) != '\0')
				++i;
		}
\end{lstlisting}
\end{samepage} \pagebreak
\textbf{getline} ve \textbf{copy} fonksiyonları programın başında deklara edildiler, tek bir dosya içinde bulunduklarını farz ediyoruz.
\par \textbf{main} ve \textbf{getline} bir argüman çifti ve döndürülen (\textbf{return}) bir değer (\textbf{value}) aracılığı ile iletişim kuruyorlar. \textbf{getline}'da argümanlar bu satır ile deklara ediliyor
\begin{lstlisting}
		int getline(char s[], int lim)
\end{lstlisting}
bu satır, ilk argümanın, s'in, bir karakter dizisi olduğunu (\textbf{array}), ve ikincisi ise, \textbf{lim}'in bir tamsayı (\textbf{integer}) olduğunu belirtiyor. Bir

\end{document}
